<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.101.0"><title>Fast reciprocal square root... in 1997?! - Shane Peelar's Blog</title><meta name=description content="This article is part of my series on reverse engineering Interstate &lsquo;76, with my current goal being to add a Vulkan renderer to the game. I&rsquo;m basing this work directly on UCyborg&rsquo;s patches which include many much-needed fixups to the game, including my own patches for the netcode.
Introduction Everyone is familiar with the famous fast reciprocal square root function in the Quake 3 source code. And, as noted on Wikipedia, solutions have existed for computing the fast reciprocal square root for many years before that, with perhaps the earliest implementation in 1986."><style>:root{--bg-color:floralwhite;--fg-color:#1c6e8c;--text-color:#444;--heading-color:#222;--tagline-color:#898989;--top-sep-color:#888888;--date-color:#666;--bar-nav-color:#777}</style><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/ui.css><link rel=stylesheet href=/css/iosevka.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Raleway"><script type=text/javascript>var _paq=window._paq=window._paq||[];_paq.push(["disableCookies"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){t="https://matomo.inbetweennames.net/",_paq.push(["setTrackerUrl",t+"matomo.php"]),_paq.push(["setSiteId","1"]);var t,n=document,e=n.createElement("script"),s=n.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src=t+"matomo.js",s.parentNode.insertBefore(e,s)}()</script><noscript><p><img src="https://matomo.inbetweennames.net//matomo.php?idsite=1&rec=1" style=border:0 alt></p></noscript></head><body><header class="container no-print"><div class=u-header><nav class=bar><ul><li><a href=/><img class=icon-text src=/img/prev.svg></a></li><li><a href=/about/>About</a></li><li><a href=/cv/>CV</a></li><li><a href=/projects/>Projects</a></li></ul></nav><hr class=topsep></div></header><main class=container><article><header><hgroup id=brand><h1>Fast reciprocal square root... in 1997?!</h1><h5><time datetime="2021-06-01 00:00:00 +0000 UTC">1 Jun 2021</time>
<span class=no-print>-
<a href=/tags/i76>i76</a></span></h5></hgroup><hr class=sep></header><p>This article is part of my series on reverse engineering <a href=https://en.wikipedia.org/wiki/Interstate_%2776>Interstate &lsquo;76</a>, with my
current goal being to add a <a href=https://en.wikipedia.org/wiki/Vulkan_(API)>Vulkan</a> renderer to the game. I&rsquo;m basing this work
directly on <a href=https://community.pcgamingwiki.com/files/file/1349-interstate-76-nitro-pack-aio-patch/>UCyborg&rsquo;s patches</a> which include
many much-needed fixups to the game, including <a href=/projects/interstate76anet/>my own patches</a> for the netcode.</p><h1 id=introduction>Introduction</h1><p>Everyone is familiar with the famous <a href=https://en.wikipedia.org/wiki/Fast_inverse_square_root>fast reciprocal square root function in the Quake
3 source code</a>. And, as noted
on Wikipedia, solutions have existed for computing the fast reciprocal square root
for many years before that, with perhaps the earliest implementation in 1986.</p><p>While I was working on reverse engineering Interstate &lsquo;76, I discovered that Activision
had their own implementation in use from at least 1997, and that it shares some similarities
with the Quake 3 approach. Interstate &lsquo;76 is based off the Mechwarrior 2 engine &ndash;
If I had a copy of Mechwarrior 2 (DOS version) on hand, I could confirm
if this was present there as well, which would date this technique even
earlier! In this post, I&rsquo;ll explain how it works.</p><h1 id=the-tldr>The TL;DR</h1><p>The approach used in the Mechwarrior 2 engine computes an approximation of the reciprocal
square root using the x87 instruction set at <code>float64</code> (or <code>double</code>) precision.</p><p>It is almost exactly the same as the Quake 3 approach except that the initial guess is computed differently.
It still uses Newton-Raphson with a few manual adjustments. The function seems to be
accurate within 4 significant digits in the worst case from some brief testing I&rsquo;ve done.</p><p>The initial guess is computed using a Lookup Table (<a href=https://en.wikipedia.org/wiki/Lookup_table>LUT</a>) to
obtain <a href=https://en.wikipedia.org/wiki/Significand>mantissa</a> bits. It is best illustrated with the following C++20 code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>LUT</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>generateLUT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>256</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>float64bits</span> <span class=o>=</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>|</span> <span class=n>UINT64_C</span><span class=p>(</span><span class=mh>0x1ff00</span><span class=p>))</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=k>const</span> <span class=n>d</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>float64bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=k>const</span> <span class=n>rsqrt</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>u64rsqrt</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rsqrt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=k>const</span> <span class=n>high32bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>u64rsqrt</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//&#34;round half-up&#34; operation: add 010000000000b (1 &lt;&lt; 10): lower bits of mantissa are thrown out.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//this has the effect of rounding the mantissa within 9 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//using the &#34;round up&#34; rule at the 10-bit mark.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//likely a bug in the original code: should be 0x800 to correctly round to 8 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint32_t</span> <span class=k>const</span> <span class=n>high32bits_rounded_up</span> <span class=o>=</span> <span class=n>high32bits</span> <span class=o>+</span> <span class=mh>0x400</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=k>const</span> <span class=n>mantissa_high8bits_only</span> <span class=o>=</span> <span class=p>(</span><span class=n>high32bits_rounded_up</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>UINT32_C</span><span class=p>(</span><span class=mh>0xFF</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//store the 8 bits of mantissa remaining
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LUT</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>mantissa_high8bits_only</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>LUT</span><span class=p>[</span><span class=mh>0x80</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xFF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The exponent of the guess is determined using a formula that operates directly on the exponent field of the input itself.
The LUT has 256 entries, each corresponding a <code>float64</code> in the range $[0.5,2)$:</p><ul><li>$[0.5,1)$ iterated at a granularity of $0.00390625$ (the first 128 entries)</li><li>$[1,2)$ iterated at a granularity of $0.0078125$ (the second half of the LUT)
Each entry contains the 8 most significant mantissa bits of the reciprocal square root for a <code>float64</code> corresponding to that entry.
It is manually adjusted to create more desirable characteristics when approximating the reciprocal square root of a <code>float64</code> in the range of
$[1,2)$.</li></ul><p>Note that the LUT wasn&rsquo;t precomputed and stored as a static array in the binary &ndash; it was generated in the initialization
sequence of the engine. To be honest,
I&rsquo;m kind of glad &ndash; it would have made this analysis a little harder to do!
The code above could easily be made <code>constexpr</code> with a few tweaks.
It compiles to <a href=#lut-asm-comparison>nearly the same code</a> as the original when built with MSVC 2019.</p><p>The actual fast reciprocal square root function computes the result as follows:</p><ol><li>Compute an initial guess for the result:<ul><li>the exponent bits for the initial guess is determined through a formula that involves only addition and division by 2 (bit shift)</li><li>the mantissa bits for the initial guess is determined using the lookup table</li><li><code>or</code> these values together to form a valid <code>float64</code> &ndash; this is the guess</li></ul></li><li>Perform one iteration of Newton-Raphson on the initial guess</li><li>Multiply the result by the constant $1.00001$</li></ol><p>Below is my own reverse engineered C++20 version of this function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=k>const</span> <span class=n>scalar</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>scalar_bits</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>scalar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=k>const</span> <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>scalar_bits</span> <span class=o>&gt;&gt;</span> <span class=mh>0x2d</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//LUT[index] contains the 8 most significant bits of the mantissa, rounded up.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//Treat all lower 44 bits as zeroed out
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>mantissa_bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>LUT</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=c1>//Exponent bits are calculated based on the formula in the article
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>exponent_bits</span> <span class=o>=</span> <span class=p>((</span><span class=mh>0xbfcUL</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar_bits</span> <span class=o>&gt;&gt;</span> <span class=mh>0x34</span><span class=p>))</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x34</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//exponent_bits have form 0xYYY00000 00000000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//mantissa_bits have form 0x000ZZ000 00000000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//so combined, we have    0xYYYZZ000 00000000 -- a complete float64 for the guess
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>combined_bits</span> <span class=o>=</span> <span class=n>exponent_bits</span> <span class=o>|</span> <span class=n>mantissa_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>initial_guess</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>combined_bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>half_initial_guess</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>initial_guess_squared</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=n>initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//One iteration of Newton-Raphson
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=k>const</span> <span class=n>newton_raphson</span> <span class=o>=</span> <span class=p>(</span><span class=mf>3.0</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar</span> <span class=o>*</span> <span class=n>initial_guess_squared</span><span class=p>))</span> <span class=o>*</span> <span class=n>half_initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//post-hoc fixup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=k>const</span> <span class=n>fixup</span> <span class=o>=</span> <span class=n>newton_raphson</span> <span class=o>*</span> <span class=mf>1.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fixup</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=-compiler-explorerhttpsgodboltorgzoylghafbqd5qcxaywpybmcmbrdblaf1qccaapecam1qdscblzaqwbtmqbgafljvocqaz0wafab4ga5aayppafzdsrzrvdiapacyaqjt2kr7zatx1kmwugdcqvgfcatrrab2akykr6adj5ataa5zwajtgiuxgahvcfcc1o7rxd3l1j4szpqjcncmiei0wtlnogamziamtnv09i0sskqoic4lciqknk6truhqfetocok6eaeojvadiza4phqbmaorhlabqtwwbumid7e0zaeevty3mbd3kifx6q2boz7vxadyctnztbgmia4eep3ob0u122btmybaqglopwa9aaqj4afqqvxorfyqaa7v9nmgtnghjtmojoqpruhngfnlciztqljgjsmgqqe8eaqcnehca4xcauecnjmfzamwnjghaa6qieogm1daohagtatgawhkhi1adynxg3lrieiai7vofpj4asqi1ojze2xewadciiiseprhfmfs8e5yzhjfriylnqgqjsqmwhk7mmg8nfikgwkxnmahfursnuaqnjhqxbmnfopgs37als0ztgbkrtb6o7kgqrmapearacagioax1koygcehc2dheds2wnqagshnfacxgvcidxmhaifqiujhfscejspnronygoyqna5vltujssc3ie5rlx0vjq2bowaganbsbfavqz8qz5xkil55qcckwkcpxshgwdikiedlnokyjl2baacad6dq2baiykab4ujab4ur4qaijs2bhqsclqflswbwbekkydhyiqjmvpujrjybdxagbbadhfkhwhutcpgbdifgiv8mxesryy6nsegghg7gnlx2ycu8gkayj9c6twilolqszuk2bbagbuxi7ojebdkgyayswqxfhpfmgxmyzybaqmatymwcnaqtigzge2bamjijwvbudimitchxwyzf2jobr2k6tx6czeu2bj0lgvi2embdocaic7k5maety2uoeuhzuozlmeei7ekrlmw1blxmxia5p2kvndsjimxwsvpugga1qqogbvczlpfuafdo9xadggx11rienzuvc51vlr5dwbqqc0dtpbncst2bv2ggseiehvnbfzzioftrlcdowenet3andcrxerj4iqmdvelanlranoya9lscbsfqgpzjo2jhqwxchhymzmogviyjwcve8tmihpxnbgjjhotcak44heditegkybmyqjbjjzpvsm2kvrmbdsudgn8nsxii8sujxjgmxxnaezorm1h4plmys1ujq4nslyajym3uqu8fyy7k9wqow0ekpq06l5xjcqgexqu6q1u06c2bpc38qwedtiuw47g4zi0irjcwqebb5vgtncagsysfs4ta2hcxxnlxdoqyrddubvirmhetcabi2fuzn2bhdwapdovkydnvoyxo23l5xt0gmd3bxel7uzw5mhxsz65qgz24yu3ahv3qmfbrateps1nek1g6d1ojxa5fycjdouobufylcefkvdl2yowtxhtwkmjdltwedpflavs46zoqgeyf5slh4boebkdtdd6pcetbm6dzpjxtqbhyjdwrhl2bkuk6ykoflsocifqnpvybefwurwd4uskohbby02ylkekbpicdi1syogmwdko0ijsf0bahbsief1dg1ijq1ymgqgaouogrxtkmkoakzhawgydeuchfscqbhfuyxxj3f2oqsqlldism8t5iqwjian3oj3krsyahyhefphrsjidykzqvbawnuqb23pfgkqdoh8kgrexpjf7guqaecwn9vzxdtpeoceaqb4byp2bo2bkyvb2ykqbwcnfsjmig7mbknktojtmwnmwirsaw4nwfooniqac8iiobsfzaxx5lp5wkfe6xe5nrnkiwog6dsjpeqgb472b1hveefiolxyyuqzahal3c6jsbkjofyo0t0sz4jymgs8tf44xmqzwfwnahzropds6srrinsfqfpdydtywnmfqzp1lfh8qiuiuivbkacf8jsduelgqcsqowgdjirlg4alaghxnicbgtymzilqeawmxcg5f4cd3llswn0aendawajp4pjhjemhc3fwiau9bgmk9nysiktaawrsomhkiwiqedena2brksjjfoizfvfip4pxfsxlrlk4am2by6dlgywxriasuvzqfgaspzuc9yrjrocscevbr4lkullrrayzkwquiycwbwk5bgvzmgwdciqpqpkusvfrql3q7hyzgbq7l9iavufo6bzqlwlwrqwkggerv4btxa9m21w2rqvcsbeelpqehhbxanbls6xtyla2bngemzlhjbqbicb7wbetvmnn9ru3gjjqaeuciwrizrmabccjgberbaaagaerfgqky2g5101xltiedtdaa59ohvpzyw0vkn0www5xbs1rqehm00mznszrqom4noak1rpncloerinqx2qfgpa4gub2bvnrm6resb0r0ewoztk7oj9poymoaxnodht4s6agcxkxpprgpbyqjigdhopydycqpr2hxchyayc0wekwikkhxjxqreoxdd8qdqxn02ehep8thtuqepybe0dy7oetagaizhhwvjtirbckoqx4lcoa28vshc0dbhagkabzbgaa1gfpx3wcn1nwqgekj8lqgi0uvyrecxmrxs6x02b6xg01ypu2brhnkpkqo11nhnenumymwf9jjktnprpdcardmmpmboke90tp2cirnjstjxaukc4ivpxjxa2bloh4kyqe85ogccemjesomlkzvlojg91ajnrlsoc6st1zllewtedmcmbcksugsftkzvpnsqq6i7nabkfizx1dkokfxofdbq4wbmragdcszeztoqyytmuzkkqtc1tgs1qlznkicpdq3z54dledttuu5hqjhf3092bsbertvpmiq895867jeemwcifkuph2yhvcymuxgy8grwnk9uq7nkoxeic8ul8xeyzstrfrqwkur2bw2bygdkgxjxfzjelrk8oat9fyq4eonl8rxukuhiqvniur1kl8qbiqgt4iri9u3ut6aa16ykbwsshe2bzytwhqsutasgbniw7lvfutau2bnrsjp7sql8kjpsxrtms9znpdofvwsgy9lk8uuc43vu1dya2bcrof6woqh7bejpkmm97ppm3a5lezddw6un64t7r6n5b7evuvu5hfdag2ecbwgewbbx1dt7z2bgdq71eclfrozgqeaffuqno75l3lflona635ywv7srlrldluc6hzjwei9v7n0h8dy2b69dcirh9ob2br9lyf3dsjv2bvpgsgmgal2bbxshf0fsp4vccuzg3qkemrjwrtnni0cqeibyzgtpnvb8qssv6l5osmv1bpfz9gqkknmvg0gpdyfclieqqbpawuunodmsx5hxbwjweqbij8jvinoea3a3dsl1nrtgyxlgygwitbwxuzybwncfqaqbgeqjwlgokugqoqugekqeqxkgqugboqayoawajasvpadgmgcgcaxaalavqdqlcygxsacpgpa2b8xkcauiaqea71koihkqougdlymagettojg2bqladcyadgfg0gfadoafkuuq0kemc1rydgr8eouqr2uitgchowsoinav4ka9g7fpgaljgngdgiofgagyqmqsqlqpqbqfqnqdqawawfqpauixksaayjjmoxkkqduwtamwmduo4gylqcqimmdujwmjciqozaaerrustczwzakowwriswawfovwtgbwawdopiaozqdibiogtiwouiyo2gpizoqoroviugfopoewoozqywoo8oyyko8ygo2byrolilinovotogoqfgyoybylghfpfauqxa8qncfumnfbd8cax4kglccaxaqgegjsfrjowampahmfyzctymfqpqefgpftgncaubqnwi0bgw4zgqatcz43umaqqca2amy6qzakava9aqraxafavaa4a8gsgygrof0zaesdcf0v4jcebrddcoyz4ijvgogygrgrqlgihaqdgrghzxgtg2bawq2bwkqrq8q1it0bw2bamqtzfsyk2bqrq3flqlqtqwcdqxyea34f0nk6ymwowkq0w6lcwiquqpqbisghw0i5w1w2badw5jribwuekgaieafwu0oewtngfu4cfuvauawtuiq0mipaa0e4mjzfuqei843qneoyzipocwcahwuo7inwiyiyugiosob0gm8osop07oli0wzoyyym1oqm2bojo0yfi0nomojo1ibi1m8miy0y6zqbeqewtzjbsggyur4fx4rq2y2by1wiqeexhv46uf0u0dyaigqcwpyie6iq4jsl4j7m4gws4xaynexglonizlgdamdwdwbbwefxutwrctwl4n4ua4f4owqetaq40gue6eceraty9s6e6gqw1mew3gmwquqw2bamwuw9qeanqngqceifcomsodi2wdm2bohivwjm6okaeckmziriuotcwmxibm0cr86m1osc2o2bm9owyocrokczmmmv89way6owcky1lmyxyciwtp4vdcunmeiqitgfsve2bru4ecmmkuaiugqmcgdizi3ij4cqbysscqbwzgmxliksnsj4blf0w8beegkkzjqcdmdkaifisiqs4sks8s1ass2bmasi0svsmte4pi5aaszgi2bzofs9sxihanmbs0gcscyvsjsys9aas4gws34dmxkl2bzsvqbgfs7syyk4mykkiyckayu0vy9y2bsrypsoqaix2blip4kghhby1kpkaf0es3hekugckmslkdy9agk3qbggwdwu4ssizbajkoyecpktygq6kxs3qhy3qncfs0k2bkdipykkdaaslykuszy5q1qmfkqxk6cpgxqgs9ueavkzip4bcqcx0asyeaiak4cshkshk4iaoqkaosgwdwlsxqw4yq0imqtmcgj4nyekis9a0sp4zaamo6ky8yh6zkj4bqnmpnzmaubgbwe4lstd67i04la0ihaxq28yq46widuizugi2br6yaqkfitiua0gss04idgdui8itdotifmctazskkyysqyk6ghs7yukgwdq8aha8gsmla0gxqlsnargsgk4aozaimnglm7g0mrsosymwajymm2k2bkvqbm2bypmnmhaza0wuwwwgypi6a7wyy1wtwxwjwimbwgytqng0w5gg2pkuoyqmk3kqmoaywlqum3yhk66qymyvqti4pm25mystgugsg6vpa4qio6k6s6p2z6l2160gtm7wnioynsrwmo04pit23sz24wqs8wpq2m6wkqyho2bwragahq22woh2tqyvqwk4ky2nk2bqqk4a7ogwpyxm6q04kgc8nmtq6ylurg82kk7k8km2iw0uno5ulw8ookqfbagu7u3hj7ugpkju2bcuk5chomkhetujume62zomg5q8qzgtgxuww52ye2i7e0k2bej6mquqlkq2uu6gar2ba2bo2b861uokpey2wigejej2by8beh2bgoegmtgnwn2b92bodxifqzkiszcha6qe4si982bkii6hy7qycja6yg4mczgochcpclc5ynczkjcv4pancoeq4yyqqdbys2baxazb7faycheicwbgiaa3d3d><a href=https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVDIApACYAQjt2kR7ZATx1KmWugDCqVgFcAtrRAB2AKykr6ADJ5aTAA5ZwAjTGIuXgAHVCFCc1o7Rxd3L1j4szp/QJCncMieI0wTLNoGAmZiAmTnV09i0sSKqoIc4LCIqKNK6trUhqFetoCO/K6eAEojVAdiZA4pHQBmAORHLABqTWWbUMId7E0ZAEEVtY3Mbd3kIfx6Q%2BOz7VXadYctnZtbgmIA4Eep3Ob0u12%2BTmYBAQgLOpwA9AAqJ4AFQQVxorFYqAA7v9NmgtnghJtMOJoqpRuhNgFNlCiZtQljgJsMgQQE8EAQCNEhCA4XCAuECNjMFZaMwnJghAA6QIEOGM1DAOHaGTaTgAWhkHi1ADYNXg3LriEIAI7VOFPJ4ASQI1OJzE2xEwADcIiISepRhFMFS8E5yZhJfRIYlNqgqJsqMwhk7MMg8NFiKgWKxNmaHFUrsnUAQnjHqXbmNFopgs37aLS0ZtgBKrtb6O7KgQrmApEaracAGIOax1kOYgCehc2DhEDs2WNQAGsHNFacxGVciDXMHaIfQiUJHfsCEJSPnrOn/YGoyQnA5VLTUJssC3iE5RlX0VjQ%2BoWagAnbSbFAvQz8Qz5xkIl55qcCKWkCpxsHgwDikIEDLNokyjl%2BAAcAD6dq%2BAIyKaB4ujaB4ur4QAIjs%2BhQScLqflSwBWBEkKYDhyIQJMVpuJRJybDxAGbBADhfkhWHUtcpGbDIFGiV8mxESRyy6NsegGHg7GnLx2ycU8GkaYJ9C6twIloLQsZUK%2BBAGbuxI7OJEBDKGyAYSwQxfHpFmGXmyzYBAqmaTYmwCNaQTIgZGE2BAMjiJwVBUDIMiTChXwyZF2joBR2k6Tx6CzEu%2BJ0LGVI2emBDoCAIC7k5MaeTY2UOEuhzUOZlmEEI7EKRlmW1blxmxia5p2kVnDSjImxwsVpUgGa1QQOgbVcZlPFuaFdo9XaDgGX11RieNZUVc51VLR5DWbQQc0dTpbnCSt%2BV2ggsEIEhVnbfZZiOftrlCdoWENet3AndcRxeRJ4iqmdVELaNlraNoya9lSCBsFQGpzjo2jhqWxChhYmzMOgVIyJwcVE8TMihPxnBgjJhOTCAk44hEDIteGkYbmYQjbjjzpVsm2KVrMBDSudGn8nSxII8SUJXJgMXxnaEZOrM1h4pLmys1ujq4nSlYAJyM3uQu8fyY7K9WqOw0eKPQ06l5XJCQGExqu6q1U06C%2BpC38qweDTiUw47g4zI0irJCwQEbB5VgtNCAgsysFS4TA2hcXXnlxDOqYrDDubVIrmhetCAbi2fUZN2bHdwAPdoVkYdnvoYXO23l5XT0GMD3Bxel7uZW5mHXSZ65qGz24YU3aHV3QmfbRATePS1NeK1g6D1/OjxA5FyCJdouoBUFyLCeFkVdl2YOwtxHtwkMJDLtWedPfLavs46zoQgE/yF5sLH4boeBkdtD/D6PcetBM6dzPjxTQbhyJdw/rhL%2BkUk6/yKofLsoCIFQNPvybEfwuRWD4usKohBBy02ylKEkbpiCDi1syOgmwDKO0IJsF0bAHBSieF1dg1IjQ1ymgQGaOUOGrXTKmKoakzhaWgYdEu/chFsCqBhFuyxxJ3F2oQSqLldiSM8t5IQwjiAn3Oj3KRsYAhYHEFPHRsjiDyKZqvbAwNUqb23pFGKqDoH8k/gRExpJf7GUqAECWN9VZxDtPEOCeAqB4BYP%2BO%2BkYVb/2YKQBWcNfSjmiG7MBkNkTOjtmwNMWIRSAW4NwfOONiQAC8IioBSfzAxX5lp5WkfE6xe5nrNkiWog6dSjpeQgB47%2B1hvEeFIolXYyUQZaHal3c6/JsBkjoFYO0T0sz4jYMgS8TF44xmqZWFWNAHzrOpDs6srRInsFqfpDyDTYw/nmfQZp1lFH8QiuIUIVBkACF8JsDU/ELGqCsQowGdjIrLG4AlAGhxNicBGTYMZILQEaWmXCG5f4CD3LLswN0AEnDAwAJp4pJhJEmHc3FwiaU9BGmK9nYsikTAAWrSomhKiWIqEDeNA%2BRKSJJFOizFvFIp4pxfSxlRLk4am%2BY6dlgYWxRiasUvZQFgAsPZuc9yRjrocsCEvBR4lkULLRRA/yZKWquIycwBwK5BGvzMGwDCiqpQPKUSVFRqL3q7HYZgBq7L9iavufo6BZqLWlwRqwKgGErV4BtXa9m21w2RqVcSBEElpQeHhbxANbLS6xtYLa%2BNGEMzlhjbQBIcb7WbETVmnN9rU3gJJQAeUCIWRiZRmabCCJgbERBaAagAErFgQKy2g5101XLtIEDtdAa59oHVPZYw0vk/N0WWw5xbs1RqEHm00mZnSzRQom4NoaK1rpNcLOErINQx2QFGPA4gUb%2BvNRm6RESb0r0eWOztk7oj9poYmoaxNODHt4s6AgcxKxPpRgpbYQJIGdhOPydYcQpR2hXCHYAYc0wEkwIkkhxJXQREoXdd8QdqxN02EhEp8tHTuqePyBE0dY7oETagaIZhHwVJTirbckoqx4lCOa28VShC0DbHaGkABZBgAA1GFpx3WcN1Nw/qGEkJ8LqgI0uvyREcXmrxS6X0%2B6xg01Ypu%2BrHnKPKqo11NhNENUMyMwF9jJKTNPrpdCarDmmPMboke90TP2cirNJSTjxAuKc4ivpXjxA%2BLoH4kyQE85OGCceMJESomLKZvLOJg91aJNrlSOc6ST1ZLLEWTEdMCmbCKSUgsFTkzVPNSqq6I7nabkfiZx1DkOkfXoFdBq4WBmRaGdCsZEztOQYyTMuZKKqtc1TGs1QLZNkiCpDQ3Z54DlEdttUU5HqJHF309%2BSbertVPMiq895867JeeMwCiFkUph2YhVCymuxgY8GrWNk9uq7nkoxeic8uL8XEyZSTRFRqWkUr%2Bw%2BYGdKGXJxFZJElrK8oat9Fyq4EONL8rxUKuHIqvniuR1Kl8qBIQGT4irI9u3ut6aa16ykbWSSHe%2BzYtwhqsutasgBniw7LVFutau%2BNrSJp7Sql8KjPSXrtMs9ZnpdOfVWSGy9lK8Uuc43vU1/dYa%2BcRoF6Woqh7BeJpkMm97PPM3a5LezDdW6Un64t7r6N5b7eVuVU5hFdaG2ECbWGeWbbx1dt7Z%2BgdQ71eCLfROzGQeaFFUQnO75l3LFLoN/a635YwV7sRlrldLuC6hZJWei9V7n0h8DY%2B69Dcirh9oB%2Br9lYf3DSJv%2BvPGSgMgaL%2BBxSHF0FsP4VccUZg3QKemrJwRtnNi0CqeIBYzGtPnVb8QSsv6L5Osmv1BPfz9GQKkNMVg0gPDyFcLIeQqBpAwuUnodMsx5hXBWJweQbIj8JVINOEA3A3DSl1NrTgyxlgyGWITbWXUZYbWNCFQaQbgeQJwLgOKUgQ/OQUgE/KQeQXkGQUgB/OQaYOAWAJASVPAdgMgCgCAXA/AlAVQdQLCYgXsacPgPA%2B8XkCAUIaQeA71KoIhKQO/UgdlYMAgetTOJg%2BQLADcYAdgfg0gfAdOAfKUUQ0keMc1RYDgr8EoUQr2UITGChOwSOI/NAv4KA9g7fPgaLJgNgDgIofgAgYQMQSQLQpQbQFQNQDQAwAwFQPAUIXkSAaYJjMoXkKQDUWtaMWMDUO4GyLQc/QiMmDUJwMjCIqoZAaERRUsTcZwZAkoWWRISwawfoVwTgbwawdoPIAoZQDIBIOgTIwouIYo2gPIzoQoRoVIugFoPoewOoZQYwOo8oYYKo8YGo%2ByRolILInoVoTogoqFGYOYBYLgHfPfA/UQxA8QNCfUMnfBd8CAX4KglCCAXAQgEgJSf/RJOwAMPAhmFYZCTYM/fQPQe/fgp/F/TgNCaUbQNwI0bgW4zgQAtCZ43UMAqQCA2AmY6QZAkAVA9A/QrAxAFAVAA4/A8gSgYgroF0ZAEsDCF0V4jCebRDDCOYz4iJVgOgygRgrQlgihaQDgrghZXgtg%2BAwQ%2BwkQrQ8Q1It0bw%2BAmQtZFsYk%2BQRQ3fLQlQtQwcDQxYeA34f0Nk6YMwowkQ0w6LCwiQUQpQbIsghw0I5w1w%2BADw5jRIbwuEKgaIEAfwu0OEWtNGfU4cfUvAUaWtUIQ0mIpAa0E4MjZfUqEI843QNEoYZIpoCwCAHwUo7InwIYiYUgIosob0gM8osoP07olI0wZoYYYM1oqM%2Bojo0YfI/0nomoJo1IbI1M8MiY0Y6/ZQbEQeWtZjBsGgYUr4/fX4rQ2Y%2BY1WIQeExhV46UF0u0DY/AIgQCW/PYiE6IQ4jsl4J7M4gwS4x/aYNEXGLoNiZ/Lgd/AmDwDwb/bWEFXUTwRctwL4n4uA4/f4owQEtAq40gUE6ecErATY9s6E6gQw1MEw3gMwqUqw%2BAmwuw9QEANQNgQceIfcOMsodI2wdM%2BoHIvwJM6okAeckMzIRIUotcwMxIbM0Cr86M1oSC2o%2BM9owYoCrokCzMmMv89wAY6oWCkY1lMYxYCiWtP4VDcUNMeiQITGFsVE%2BrU4ECMmKUaIUgQmCGDizi3iJ4cQbYsscQbwZgMxLikSnSJ4BLF0W8bEEgKkZjQCdmdkAiFisiQS4SkS8S1ASS%2BMAS/i0SvSmtE4Pi5AASzgI%2BZOfS9SxihANMbS0gcSCyvSjSyS9AaS4gWS34dMXkL%2BZSvQbgFS7Syyk4MyKkIYCKaYU0Vy9y%2BSrypSoQaIX%2BLip4KgHhBy1KpK/AF0eS3heKUgCKmSlkDy9AGK3QbgGwDwU4SSIZBaJKoYecPKtygq6KxS3QHy3QNCFS0K%2BKDipykkdAASly/KuSzy5q1qmFKqxK6CPGXqgS9uEaVKzip4bcQCX0AS/yeaiak4CShkShK4IaoqkaoSgwDwLsXQW4yq0iMQtMCGJ4NYEkIS9a0Sp4ZAAMO6ky8yh6zKJ4BQNMPnZMaUbgbWE4LsT/D67i04La0IHaxq28Yq46wiDuIZUgI%2BR6yaqkFitiua0GsS04IDGDUi8itDOTIfMCTazSkkYysQyK6GhS7yuKgwdq8aha8Gsmla0gXQLsNarGsGk4aOZaimngLm7G0mrSoSymwajymm2K%2BKvQBm%2BypmnmhAZa0WuWwWgypi6a7wYy1WtWxWjWimbWgytQNG0W5Gg2pKuOYqMK3KqmoayWlqum3yhK66qymyvqti4pM25myStgUgSG6VPa4q/io6k6s6p2z6l2160gTm7WnioynSrWmO04Pit23Sz24WqS8Wpq2m6Wkq/yhO%2BWragahq22wOh2tq/yvqwK4Ky2nK%2BqqK4a7OgwPyxm6q04KgC8NMTq6YLurG82kK7K8Km2iW0unO5ulW8OoKqfBAGu7u3hJ7UGpKju%2BcUK5CHoMKhetujume62zOmG5q8qzgTgXUWW52ye2I7e0K%2Bej6mquqLKq2uu6G/ar%2BA%2Bo%2B861uoKpey2wigejej%2By8beh%2BgO/egmTgNwN%2B9%2BoDXifQzkiszchA6QE4Si98%2BkIi6/HY7QYcjA6YG4mczgOchcpclc5YNczkjcv4pAncoEq4yYqQDBys%2BAxAzB7faYcheICwbgIAA%3D%3D>&#187;> Compiler Explorer</a></h2><p>When compiled for x86 using only x87 instructions and <code>-Ofast</code> on Clang 11, it produces <a href=#rsqrt-asm-comparison>similar assembly</a> to the original with a few differences.</p><h2 id=patched-version-of-game-with-screenshotsrsqrt-screenshots><a href=#rsqrt-screenshots>Patched version of game with screenshots</a></h2><p>So, I went ahead and replaced this with a much more accurate <code>rsqrt</code> in I'76. Here&rsquo;s a comparison between the original and both versions, with differences marked using
purple:</p><p><img src=diff.png alt></p><p>Hardly any difference! The original version of the code was definitely &ldquo;good enough&rdquo; for what it needed to do.</p><h1 id=the-long-version>The Long Version</h1><h4 id=foreword>Foreword</h4><p>You know, back when I first started delving into reverse engineering I'76 ten years ago,
tools like <a href=https://ghidra-sre.org/>Ghidra</a> weren&rsquo;t available. The state of the art
was probably <a href=https://www.hex-rays.com/ida-pro/>IDA Pro</a>, a tool suite that while reasonably
priced for what it did, was way out of the price range for me, a third year undergraduate
student. Sure, pirating it was an option, but if you wanted to do things the honest way <em>and</em> on a budget, it was
hard to do better than <a href=http://www.ollydbg.de/version2.html>Ollydbg</a>, a free debugger
and disassembler for 32-bit x86. Now, ten years later, the landscape looks radically
different. There are so many fantastic tools available for doing this kind of thing,
and it has never been easier to mod your favourite games as a result.</p><h2 id=introduction-1>Introduction</h2><p>I first discovered the code when identifying functions in the startup sequence of <code>nitro.exe</code> using Ghidra. Some fairly
normal initialization code, then I came across this function that populates a LUT using, seemingly, one byte from the result of a <code>1.0/sqrt(x)</code> on a <code>float64</code>.
Below is the decompiled version of the function as provided by Ghidra:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>generate_weird_lut</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>local_10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>SQRT</span><span class=p>((</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)((</span><span class=n>uVar1</span> <span class=o>|</span> <span class=mh>0x1ff00U</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0xd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)))</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>global_lut</span><span class=p>[</span><span class=n>uVar1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>byte</span><span class=p>)(</span><span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uVar1</span> <span class=o>=</span> <span class=n>uVar1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>uVar1</span> <span class=o>&lt;</span> <span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>global_lut</span><span class=p>[</span><span class=mi>128</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Ghidra did pretty well here, except the cast to <code>double</code>, which is closer to a bitwise cast than a <code>static_cast</code>:</p><details><summary>Assembly listing for <code>generate_weird_lut</code></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF60</span> <span class=o>|</span> <span class=mi>83</span><span class=nv>EC</span> <span class=mi>10</span>                  <span class=o>|</span> <span class=nv>sub</span> <span class=nb>esp</span><span class=p>,</span><span class=mi>10</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF63</span> <span class=o>|</span> <span class=mi>33</span><span class=nv>C0</span>                     <span class=o>|</span> <span class=nv>xor</span> <span class=nb>eax</span><span class=p>,</span><span class=nb>eax</span>                             
</span></span><span class="line hl"><span class=cl><span class=err>0049</span><span class=nf>AF65</span> <span class=o>|</span> <span class=mi>894424</span> <span class=mi>00</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=p>],</span><span class=nb>eax</span>              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF69</span> <span class=o>|</span> <span class=mi>8</span><span class=nv>BC8</span>                     <span class=o>|</span> <span class=nv>mov</span> <span class=nb>ecx</span><span class=p>,</span><span class=nb>eax</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF6B</span> <span class=o>|</span> <span class=mi>81</span><span class=nv>C9</span> <span class=mi>00</span><span class=nv>FF0100</span>            <span class=o>|</span> <span class=nv>or</span> <span class=nb>ecx</span><span class=p>,</span><span class=mi>1</span><span class=nv>FF00</span>                            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF71</span> <span class=o>|</span> <span class=nv>C1E1</span> <span class=mi>0</span><span class=nv>D</span>                  <span class=o>|</span> <span class=nv>shl</span> <span class=nb>ecx</span><span class=p>,</span><span class=nv>D</span>                               
</span></span><span class="line hl"><span class=cl><span class=err>0049</span><span class=nf>AF74</span> <span class=o>|</span> <span class=mi>894</span><span class=nv>C24</span> <span class=mi>04</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span><span class=nb>ecx</span>            
</span></span><span class="line hl"><span class=cl><span class=err>0049</span><span class=nf>AF78</span> <span class=o>|</span> <span class=nv>DD4424</span> <span class=mi>00</span>                <span class=o>|</span> <span class=nv>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=p>]</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF7C</span> <span class=o>|</span> <span class=nv>D9FA</span>                     <span class=o>|</span> <span class=nb>fs</span><span class=nv>qrt</span>                                   
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF7E</span> <span class=o>|</span> <span class=nv>DC3D</span> <span class=nv>A0504C00</span>            <span class=o>|</span> <span class=nv>fdivr</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>4</span><span class=nv>C50A0</span><span class=p>]</span>       
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF84</span> <span class=o>|</span> <span class=nv>DD5C24</span> <span class=mi>08</span>                <span class=o>|</span> <span class=nb>fs</span><span class=nv>tp</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>         
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF88</span> <span class=o>|</span> <span class=mi>8</span><span class=nv>B5424</span> <span class=mi>0</span><span class=nv>C</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=nb>edx</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=nv>C</span><span class=p>]</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF8C</span> <span class=o>|</span> <span class=mi>81</span><span class=nv>C2</span> <span class=mi>00040000</span>            <span class=o>|</span> <span class=nv>add</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>400</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF92</span> <span class=o>|</span> <span class=nv>C1FA</span> <span class=mi>0</span><span class=nv>C</span>                  <span class=o>|</span> <span class=nv>sar</span> <span class=nb>edx</span><span class=p>,</span><span class=nv>C</span>                               
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF95</span> <span class=o>|</span> <span class=mi>8890</span> <span class=mi>80</span><span class=nv>B15F00</span>            <span class=o>|</span> <span class=nv>mov</span> <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=nb>eax</span><span class=o>+</span><span class=mi>5</span><span class=nv>FB180</span><span class=p>],</span><span class=nb>dl</span>         
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF9B</span> <span class=o>|</span> <span class=mi>40</span>                       <span class=o>|</span> <span class=nv>inc</span> <span class=nb>eax</span>                                 
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AF9C</span> <span class=o>|</span> <span class=mi>3</span><span class=nv>D</span> <span class=mi>00010000</span>              <span class=o>|</span> <span class=nv>cmp</span> <span class=nb>eax</span><span class=p>,</span><span class=mi>100</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AFA1</span> <span class=o>|</span> <span class=mi>7</span><span class=nv>C</span> <span class=nv>C6</span>                    <span class=o>|</span> <span class=nv>jl</span> <span class=nv>nitro.49AF69</span>                         
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AFA3</span> <span class=o>|</span> <span class=nv>C605</span> <span class=mb>00B</span><span class=mi>25</span><span class=nv>F00</span> <span class=nv>FF</span>         <span class=o>|</span> <span class=nv>mov</span> <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>5</span><span class=nv>FB200</span><span class=p>],</span><span class=nv>FF</span>             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AFAA</span> <span class=o>|</span> <span class=mi>83</span><span class=nv>C4</span> <span class=mi>10</span>                  <span class=o>|</span> <span class=nv>add</span> <span class=nb>esp</span><span class=p>,</span><span class=mi>10</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>AFAD</span> <span class=o>|</span> <span class=nv>C3</span>                       <span class=o>|</span> <span class=nv>ret</span>                                     </span></span></code></pre></div></details><p>Only one other function referenced this lookup table, and the code was almost incomprehensible at first glance:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>weird_function</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Again Ghidra did a good job here, except for the cast to <code>double</code> &ndash; the pseudo-C code above is basically a more
readable version of the assembly listing.</p><details><summary>Assembly listing for <code>weird_function</code></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=err>0049</span><span class=nf>C310</span> <span class=o>|</span> <span class=mi>8</span><span class=nv>B4C24</span> <span class=mi>08</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=nb>ecx</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C314</span> <span class=o>|</span> <span class=nv>BA</span> <span class=nv>FC0B0000</span>              <span class=o>|</span> <span class=nv>mov</span> <span class=nb>edx</span><span class=p>,</span><span class=nv>BFC</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C319</span> <span class=o>|</span> <span class=nv>C1E9</span> <span class=mi>14</span>                  <span class=o>|</span> <span class=nv>shr</span> <span class=nb>ecx</span><span class=p>,</span><span class=mi>14</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C31C</span> <span class=o>|</span> <span class=mi>8</span><span class=nv>B4424</span> <span class=mi>08</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=nb>eax</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C320</span> <span class=o>|</span> <span class=nv>C1E8</span> <span class=mi>0</span><span class=nv>D</span>                  <span class=o>|</span> <span class=nv>shr</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>D</span>                               
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C323</span> <span class=o>|</span> <span class=mi>2</span><span class=nv>BD1</span>                     <span class=o>|</span> <span class=nv>sub</span> <span class=nb>edx</span><span class=p>,</span><span class=nb>ecx</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C325</span> <span class=o>|</span> <span class=nv>D1EA</span>                     <span class=o>|</span> <span class=nv>shr</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>1</span>                               
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C327</span> <span class=o>|</span> <span class=mi>25</span> <span class=nv>FF000000</span>              <span class=o>|</span> <span class=nv>and</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>FF</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C32C</span> <span class=o>|</span> <span class=nv>DD4424</span> <span class=mi>04</span>                <span class=o>|</span> <span class=nv>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>          
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C330</span> <span class=o>|</span> <span class=nv>C1E2</span> <span class=mi>14</span>                  <span class=o>|</span> <span class=nv>shl</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>14</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C333</span> <span class=o>|</span> <span class=mi>8</span><span class=nv>A80</span> <span class=mi>80</span><span class=nv>B15F00</span>            <span class=o>|</span> <span class=nv>mov</span> <span class=nb>al</span><span class=p>,</span><span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=nb>eax</span><span class=o>+</span><span class=mi>5</span><span class=nv>FB180</span><span class=p>]</span>         
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C339</span> <span class=o>|</span> <span class=nv>C1E0</span> <span class=mi>0</span><span class=nv>C</span>                  <span class=o>|</span> <span class=nv>shl</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>C</span>                               
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C33C</span> <span class=o>|</span> <span class=mi>33</span><span class=nv>C9</span>                     <span class=o>|</span> <span class=nv>xor</span> <span class=nb>ecx</span><span class=p>,</span><span class=nb>ecx</span>                             
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C33E</span> <span class=o>|</span> <span class=mb>0B</span><span class=nv>D0</span>                     <span class=o>|</span> <span class=nv>or</span> <span class=nb>edx</span><span class=p>,</span><span class=nb>eax</span>                              
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C340</span> <span class=o>|</span> <span class=mi>894</span><span class=nv>C24</span> <span class=mi>04</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span><span class=nb>ecx</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C344</span> <span class=o>|</span> <span class=mi>895424</span> <span class=mi>08</span>                <span class=o>|</span> <span class=nv>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span><span class=nb>edx</span>            
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C348</span> <span class=o>|</span> <span class=nv>DD4424</span> <span class=mi>04</span>                <span class=o>|</span> <span class=nv>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>          
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C34C</span> <span class=o>|</span> <span class=nv>DCC8</span>                     <span class=o>|</span> <span class=nv>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                        
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C34E</span> <span class=o>|</span> <span class=nv>DD4424</span> <span class=mi>04</span>                <span class=o>|</span> <span class=nv>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>          
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C352</span> <span class=o>|</span> <span class=nv>D9C9</span>                     <span class=o>|</span> <span class=nv>fxch</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>                        
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C354</span> <span class=o>|</span> <span class=nv>DECA</span>                     <span class=o>|</span> <span class=nv>fmulp</span> <span class=nv>st</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                       
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C356</span> <span class=o>|</span> <span class=nv>DC0D</span> <span class=mi>68115000</span>            <span class=o>|</span> <span class=nv>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501168</span><span class=p>]</span>        
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C35C</span> <span class=o>|</span> <span class=nv>D9C9</span>                     <span class=o>|</span> <span class=nv>fxch</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>                        
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C35E</span> <span class=o>|</span> <span class=nv>DC2D</span> <span class=mi>60115000</span>            <span class=o>|</span> <span class=nb>fs</span><span class=nv>ubr</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501160</span><span class=p>]</span>       
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C364</span> <span class=o>|</span> <span class=nv>DEC9</span>                     <span class=o>|</span> <span class=nv>fmulp</span> <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                       
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C366</span> <span class=o>|</span> <span class=nv>DC0D</span> <span class=mi>70115000</span>            <span class=o>|</span> <span class=nv>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501170</span><span class=p>]</span>        
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>C36C</span> <span class=o>|</span> <span class=nv>C3</span>                       <span class=o>|</span> <span class=nv>ret</span>                                     </span></span></code></pre></div></details><p>Bit shifts, floats
being treated like integers, and other interesting things abound! It <em>could</em> be what I was suspecting, a fast reciprocal square root function, but maybe
it was just a small piece of code used for something else. Not wanting to jump to conclusions, I decided
to study it a bit more. A good place to start, I figured, would be to see how this mysterious function was used. I found
fragments of code like this all over the place:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>*</span><span class=n>param_2</span> <span class=o>-</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>*</span><span class=n>param_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fVar4</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>param_2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=p>((</span><span class=kt>float</span><span class=p>)</span><span class=n>param_1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=mf>2.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>fVar3</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>param_2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>-</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>param_1</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class="line hl"><span class=cl><span class=n>fVar8</span> <span class=o>=</span> <span class=n>weird_function</span><span class=p>((</span><span class=kt>double</span><span class=p>)(</span><span class=n>fVar3</span> <span class=o>*</span> <span class=n>fVar3</span> <span class=o>+</span> <span class=n>fVar4</span> <span class=o>*</span> <span class=n>fVar4</span> <span class=o>+</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>fVar1</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>fVar8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fVar2</span> <span class=o>=</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fVar3</span> <span class=o>=</span> <span class=n>fVar3</span> <span class=o>*</span> <span class=n>fVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span></code></pre></div><p>&ldquo;<em>Wow, that sure looks like it&rsquo;s computing the <a href=https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance>squared length</a> of a 3D vector</em>,&rdquo; I thought to myself.
If <code>weird_function</code> was being called on the results of squared vector lengths, it&rsquo;s almost certain it&rsquo;s being used in vector normalization. Indeed,
in the fragment of code above, you can see some of the vector components being multiplied by the result.</p><p>Wanting to play with some new tools, I gave Cutter a try with its emulation facilities to run the machine code directly, but unfortunately
couldn&rsquo;t figure out how to get it to show the <code>ST(i)</code> registers during execution. So I moved on to
<em>x64dbg</em>, a modern debugger heavily inspired by Ollydbg.</p><p>I fired up x64dbg and set a breakpoint for right after where the function where the LUT gets generated is called, then ran it.
Once execution reached the breakpoint, I immediately replaced the instruction pointer to the start of our <code>weird_function</code>:</p><p><img src=start-of-function.png alt></p><p>Seeing where the argument was expected, I figured why not try evaluating the value <code>2.0</code>? So, I passed it in
and ran the function to completion:</p><p><img src=rsqrt2.png alt></p><p>Indeed, after running the function, <code>0.7071...</code> was sitting in <code>ST(0)</code>. That&rsquo;s <code>1/sqrt(2)</code> accurate to 4 significant digits.
&ldquo;<em>OK fine,</em>&rdquo; I thought, &ldquo;<em>let&rsquo;s try out some other values too, just to be sure.</em>&rdquo;</p><p>So, I went ahead and tried out <code>100</code>, <code>4</code>, <code>64</code>, <code>0.5</code>, and <code>1.2345</code>:</p><p>Trying with <strong>100</strong>: <img src=rsqrt100.png alt></p><p>With <strong>4</strong>: <img src=rsqrt4.png alt></p><p>With <strong>64</strong>: <img src=rsqrt64.png alt></p><p>With <strong>0.5</strong>: <img src=rsqrthalf.png alt></p><p>Finally, with <strong>1.2345</strong>: <img src=rsqrt12345.png alt></p><p>In each case, the result seemed to be accurate within 4 to 6 significant digits.</p><p>&ldquo;<em>That&rsquo;s it. I&rsquo;m convinced!</em>&rdquo; I said out loud, &ldquo;<em>&mldr;but what the hell is it actually doing?!</em>&rdquo;</p><p>The next step, I figured, would be to decompile it to C++ to help analyze it a bit easier.
This would be a manual process guided by Ghidra&rsquo;s own decompilation, which did a pretty good job, considering.
I wanted to compare it against a correctly rounded reciprocal square root to sample what the error
was across the board.</p><p>First, the C++20 version of the LUT generator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>LUT</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>generateLUT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>256</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>float64bits</span> <span class=o>=</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>|</span> <span class=n>UINT64_C</span><span class=p>(</span><span class=mh>0x1ff00</span><span class=p>))</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=k>const</span> <span class=n>d</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>float64bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=k>const</span> <span class=n>rsqrt</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>u64rsqrt</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rsqrt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=k>const</span> <span class=n>high32bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>u64rsqrt</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//&#34;round half-up&#34; operation: add 010000000000b (1 &lt;&lt; 10): lower bits of mantissa are thrown out.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//this has the effect of rounding the mantissa within 9 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//using the &#34;round up&#34; rule at the 10-bit mark.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//likely a bug in the original code: should be 0x800 to correctly round to 8 bits
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint32_t</span> <span class=k>const</span> <span class=n>high32bits_rounded_up</span> <span class=o>=</span> <span class=n>high32bits</span> <span class=o>+</span> <span class=mh>0x400</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=k>const</span> <span class=n>mantissa_high8bits_only</span> <span class=o>=</span> <span class=p>(</span><span class=n>high32bits_rounded_up</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>UINT32_C</span><span class=p>(</span><span class=mh>0xFF</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//store the 8 bits of mantissa remaining
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LUT</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>mantissa_high8bits_only</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>LUT</span><span class=p>[</span><span class=mh>0x80</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xFF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h5 id=lut-asm-comparison>Assembly comparison</h5><p>If you compile this for 32-bit with MSVC 2019, x87 only, and <code>/fp:fast</code> you will get nearly identical assembly to what is in I'76:</p><details><summary>Assembly listing comparison between the original and C++20 version of <code>generateLUT</code></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; Original I&#39;76                     |   ;New code, MSVC 2019, x86-Release with /arch:IA32 /fp:fast</span>
</span></span><span class=line><span class=cl>                                    <span class=err>|</span>   <span class=c1>; /Oy /O2 /Ot /Ob2 /Oi</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span> <span class=nb>esp</span><span class=p>,</span><span class=mi>10</span>                          <span class=o>|</span>   <span class=nv>sub</span>         <span class=nb>esp</span><span class=p>,</span><span class=mh>14h</span>  
</span></span><span class="line hl"><span class=cl>                                    <span class=err>|</span>   <span class=nf>fld1</span> 
</span></span><span class=line><span class=cl><span class=nf>xor</span> <span class=nb>eax</span><span class=p>,</span><span class=nb>eax</span>                         <span class=o>|</span>   <span class=nv>xor</span>         <span class=nb>ecx</span><span class=p>,</span><span class=nb>ecx</span>  
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=p>],</span><span class=nb>eax</span>          <span class=o>|</span>   <span class=nv>mov</span>         <span class=nb>eax</span><span class=p>,</span><span class=nb>ecx</span>  
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>ecx</span><span class=p>,</span><span class=nb>eax</span>                         <span class=o>|</span>   <span class=nv>mov</span>         <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=p>],</span><span class=mi>0</span>  
</span></span><span class=line><span class=cl><span class=nf>or</span> <span class=nb>ecx</span><span class=p>,</span><span class=mi>1</span><span class=nv>FF00</span>                        <span class=o>|</span>   <span class=nv>shl</span>         <span class=nb>eax</span><span class=p>,</span><span class=mh>0Dh</span>  
</span></span><span class=line><span class=cl><span class=nf>shl</span> <span class=nb>ecx</span><span class=p>,</span><span class=nv>D</span>                           <span class=o>|</span>   <span class=nv>or</span>          <span class=nb>eax</span><span class=p>,</span><span class=mh>3FE00000h</span>  
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span><span class=nb>ecx</span>        <span class=o>|</span>   <span class=nv>mov</span>         <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span><span class=nb>eax</span>  
</span></span><span class=line><span class=cl><span class=nf>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=p>]</span>        <span class=o>|</span>   <span class=nv>fld</span>         <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=nf>fsqrt</span>                               <span class=o>|</span>   <span class=nb>fs</span><span class=nv>qrt</span>  
</span></span><span class=line><span class=cl><span class=nf>fdivr</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>4</span><span class=nv>C50A0</span><span class=p>]</span>   <span class=o>|</span>   <span class=nv>fdivr</span>       <span class=nv>st</span><span class=p>,</span><span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=nf>fstp</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>     <span class=o>|</span>   <span class=nb>fs</span><span class=nv>tp</span>        <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>edx</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=nv>C</span><span class=p>]</span>        <span class=o>|</span>   <span class=nv>mov</span>         <span class=nb>eax</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=o>+</span><span class=mh>0Ch</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>400</span>                         <span class=o>|</span>   <span class=nv>add</span>         <span class=nb>eax</span><span class=p>,</span><span class=mh>400h</span>  
</span></span><span class=line><span class=cl><span class=nf>sar</span> <span class=nb>edx</span><span class=p>,</span><span class=nv>C</span>                           <span class=o>|</span>   <span class=nv>shr</span>         <span class=nb>eax</span><span class=p>,</span><span class=mh>0Ch</span>   
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=nb>eax</span><span class=o>+</span><span class=mi>5</span><span class=nv>FB180</span><span class=p>],</span><span class=nb>dl</span>     <span class=o>|</span>   <span class=nv>mov</span>         <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nv>LUT</span> <span class=p>(</span><span class=mh>0B66678h</span><span class=p>)[</span><span class=nb>ecx</span><span class=p>],</span><span class=nb>al</span> 
</span></span><span class=line><span class=cl><span class=nf>inc</span> <span class=nb>eax</span>                             <span class=o>|</span>   <span class=nv>inc</span>         <span class=nb>ecx</span>  
</span></span><span class=line><span class=cl><span class=nf>cmp</span> <span class=nb>eax</span><span class=p>,</span><span class=mi>100</span>                         <span class=o>|</span>   <span class=nv>cmp</span>         <span class=nb>ecx</span><span class=p>,</span><span class=mh>100h</span>  
</span></span><span class=line><span class=cl><span class=nf>jl</span> <span class=nv>nitro.49AF69</span>                     <span class=o>|</span>   <span class=nv>jb</span>          <span class=nv>generateLUT</span><span class=o>+</span><span class=mh>7h</span> <span class=p>(</span><span class=mh>0B61827h</span><span class=p>)</span>  
</span></span><span class="line hl"><span class=cl>                                    <span class=err>|</span>   <span class=nf>fstp</span>        <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>5</span><span class=nv>FB200</span><span class=p>],</span><span class=nv>FF</span>         <span class=o>|</span>   <span class=nv>mov</span>         <span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mh>0B666F8h</span><span class=p>],</span><span class=mh>0FFh</span>  
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=nb>esp</span><span class=p>,</span><span class=mi>10</span>                          <span class=o>|</span>   <span class=nv>add</span>         <span class=nb>esp</span><span class=p>,</span><span class=mh>14h</span>  
</span></span><span class=line><span class=cl><span class=nf>ret</span>                                 <span class=o>|</span>   <span class=nv>ret</span>  </span></span></code></pre></div></details><p>This is acceptable. The only real difference is the constant <code>1.0</code> is obtained via <code>fld1</code> rather than a memory reference, and the function cleans it off the x87 stack before returning (this is
a requirement imposed by the <a href=https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl>cdecl</a> calling convention). Comparing the LUT generated here with the one visible in x64dbg yielded identical results, so I was confident I got this right. Now I could actually pick this apart a bit.</p><p>You might have noticed that the LUT could have been computed entirely at compile time, or even just stored as
a static array in the executable. I&rsquo;m glad that Visual C++ 6.0 wasn&rsquo;t that smart, because it would have made this a fair bit harder to do!</p><h2 id=some-basic-analysis-of-the-lut>Some basic analysis of the LUT</h2><p>The 256-entry LUT looks like this:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm>0x00:  6a 68 67 66 64 63 62 60 5f 5e 5c 5b 5a 59 57 56 55 54 53 52 50 4f 4e 4d 4c 4b 4a 49 48 47 46 45
0x20:  44 43 42 41 40 3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 34 33 32 31 30 2f 2f 2e 2d 2c 2b 2a 2a 29 28
0x40:  27 27 26 25 24 24 23 22 21 21 20 1f 1f 1e 1d 1c 1c 1b 1a 1a 19 18 18 17 16 16 15 15 14 13 13 12
0x60:  11 11 10 10 0f 0e 0e 0d 0d 0c 0c 0b 0a 0a 09 09 08 08 07 07 06 05 05 04 04 03 03 02 02 01 01 <span class="kt hl" style=display:inline>00</span>
0x80:  <span class="kt hl" style=display:inline>ff</span> fe fc fa f8 f6 f4 f2 f0 ef ed eb e9 e8 e6 e4 e2 e1 df de dc da d9 d7 d6 d4 d3 d1 d0 ce cd cb
0xa0:  ca c8 c7 c5 c4 c3 c1 c0 bf bd bc bb b9 b8 b7 b6 b4 b3 b2 b1 b0 ae ad ac ab aa a8 a7 a6 a5 a4 a3
0xc0:  a2 a1 a0 9f 9e 9c 9b 9a 99 98 97 96 95 94 93 92 91 90 8f 8f 8e 8d 8c 8b 8a 89 88 87 86 85 85 84
0xe0:  83 82 81 80 7f 7f 7e 7d 7c 7b 7a 7a 79 78 77 76 76 75 74 73 73 72 71 70 70 6f 6e 6d 6d 6c 6b 6a</code></pre></div><p>As you can see, there is a discontinuity between <code>0x7f</code> and <code>0x80</code>, where it jumps from <code>00</code> to <code>ff</code>.</p><p>I made a spreadsheet to see how this compares to the &ldquo;precise&rdquo; result and ended up seeing that
the numerical error actually forms a repeating pattern when viewed on a log scale, which at the time
I thought was interesting. We&rsquo;ll see why this is the case later.</p><p>I tried out the decompiled version of the code by sampling inputs and comparing them with the
correctly rounded &ldquo;ground truth&rdquo; result. The code appears to give about 4 significant digits of precision
in the worst case, sometimes providing 6 or more. Not bad at all!</p><p>But how&rsquo;s this thing actually work?</p><h2 id=ieee-754-float64-refresher>IEEE-754 <code>float64</code> refresher</h2><p>Before we go down the numerical analysis path &ndash; a quick refresher on IEEE-754 <code>float64</code> (or <code>double</code> precision) representations
is due.</p><p>A <code>float64</code> value is a 64-bit datatype of the following form, where the sign bit is the most significant bit:</p><figure><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/618px-IEEE_754_Double_Floating_Point_Format.svg.png alt="Image courtesy of Wikipedia"><figcaption><p>Image courtesy of Wikipedia</p></figcaption></figure><p>Conceptually, you can think of a <code>float64</code> like you would a number written in scientific notation,
except in base 2 instead of base 10.
There are certain <a href=#ieee754-cases>special cases of this format</a> that, for our purposes, we can completely ignore for our analysis.
We assume, because we&rsquo;re dealing with an approximation, that the input is:</p><ul><li>non-<code>NaN</code></li><li>non-<code>InF</code> (i.e. finite)</li><li>normal (i.e. not denormal/subnormal)</li><li>positive (i.e., the sign bit is zero)</li></ul><p>These assumptions simplify the math
and handle the vast majority of use cases that this function would be used for. Remember:
this thing is supposed to be a fast approximation, not perfect.</p><p>There are just two more things to point out before we proceed. Given a <code>float64</code> $v$ conforming to our assumptions:</p><ul><li>The 11-bit exponent for $v$ is stored <em>biased</em> by the value $1023$ in the exponent field. This means to get the true exponent, you need to subtract it by $1023$</li><li>The mantissa for $v$ is actually a 53-bit value. The lower 52-bits are as they appear in the mantissa field, and the most significant bit is implicitly $1$</li></ul><p>For example, the value $-3.625$ is represented as a <code>float64</code> as follows: first, $-3.625 = -2^1(1 + 0.8125)$. Therefore the unbiased exponent is $1$, and
the biased exponent is $1 + 1023 = 1024$. The fractional part of the mantissa (lower 52 bits) is 0.8125, as we exclude the implicit leading $1$.
We turn that into a 52-bit integer for the field by multiplying it by $2^{52}$. Finally, the sign bit is $1$ because the quantity is negative:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>1</span>     <span class=k>10000000000</span> <span class=kt>1101000000000000000000000000000000000000000000000000</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>In hexadecimal notation, this is written as <code class=chroma>0x<span class=halfStyle>c</span><span class=k>00</span><span class=kt>d000000000000</span></code>. <code>float64</code> is kind of nice because the mantissa starts on a 4-bit (or <em>nibble</em>) boundary, so it&rsquo;s easy to see what the fractional
part of the mantissa is just by looking at the hexadecimal readout.</p><p>Working with values this way is a little cumbersome, so let us introduce some notation to make working with <code>float64</code>s a little easier.</p><h3 id=notation>Notation</h3><p>We can represent an IEEE-754 value $v$ that conforms to our assumptions as follows:</p><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{aligned}",right:"\\end{aligned}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1,trust:!0,globalGroup:!0})})</script><span>\[\newcommand{\fexp}{\mathit{exp}}
\newcommand{\ffrac}{\mathit{frac}}
\mathrm{fl}[v] = 2^\fexp(1 + \ffrac)\]</span><p>where $\mathrm{fl}[v] \in \mathbb{R}$ is the real floating point value, $\fexp \in \mathbb{Z}$ is the unbiased exponent,
and $\ffrac \in \mathbb{R}$ is the fractional part of the mantissa, $0 \leq \ffrac &lt; 1$.</p><p>This is a <a href=http://homepages.math.uic.edu/~hanson/mcs471/FloatingPointRep.html>common notation</a> used in many numerical analysis papers and
will help along our exploration.</p><p>Note that this is a &ldquo;one way&rdquo; mapping from floating point values to reals. Taking an arbitrary real number and approximating it with a <code>float64</code> requires certain <a href=#ieee754-real>conditions</a> to be met.</p><h2 id=the-fast-reciprocal-square-root-function-i76_rsqrt>The fast reciprocal square root function <code>i76_rsqrt</code></h2><p>Onto the math. Recall what our decompiled <code>i76_rsqrt</code> function looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now we&rsquo;ll take this function apart piece by piece to figure out what the magic is. The general algorithm is as follows:</p><div class=centred><ol><li><a href=#rsqrt-guess>Form an initial guess</a><ul><li><a href=#rsqrt-guess-exponent>Solve for the exponent bits</a></li><li><a href=#rsqrt-guess-mantissa>Get the mantissa bits from the LUT</a></li></ul></li><li><a href=#rsqrt-newton>Perform 1 iteration of Newton-Raphson on the guess</a></li><li><a href=#rsqrt-posthocfixup>Apply a fixup multiplying the result by 1.0001</a></li></ol></div><p>We&rsquo;ll address each step in order.</p><h2 id=rsqrt-guess>Forming the initial guess</h2><p>The initial guess is also a <code>float64</code>. Since it has three components (sign, biased exponent, and mantissa),
wouldn&rsquo;t it be nice if you could solve for each of them independently?
As it turns out, it is possible do just that! We&rsquo;ll start with an exact floating point decomposition of the reciprocal square root
and then start simplifying things to create an approximation of it.</p><h3 id=the-sign-bit>The Sign bit</h3><p>First, observe that the sign bit of the result has to be 0, which denotes a non-negative number in IEEE-754.
This is because the reciprocal square root is always a positive value. So that one was easy! :)</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>?????🔒?????</span> <span class=kt>??????????????????????????🔒?????????????????????????</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>Hey, it&rsquo;s a start!</p><h3 id=rsqrt-guess-exponent>The Exponent</h3><p>Now onto solving for the exponent field.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class="line hl"><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class="line hl"><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>One way to figure out what the exponent should be in our <code>float64</code> is to <a href=#ieee754-decomp>take the floor of the base-2 logarithm of the value</a>, denoted $\lg$:</p><span>\[\newcommand{\floor}[1]{{\left\lfloor #1 \right\rfloor}}\]</span>
<span>\begin{aligned}&\floor{\lg\left(\frac{1}{\sqrt{\mathrm{fl}[v]}}\right)} \\
=&\floor{\lg(1) - \lg(\sqrt{\mathrm{fl}[v]})} \\
=&\floor{0 - \frac{\lg(\mathrm{fl}[v])}{2}} \\
=&\floor{-\frac{\lg(2^\fexp(1 + \ffrac))}{2}} \\
=&\floor{-\frac{\lg(2^\fexp)}{2} - \frac{\lg(1 + \ffrac))}{2}} \\
=&\floor{- \frac{\fexp}{2} - \frac{\lg(1 + \ffrac))}{2}}\end{aligned}</span><p>Now, $\fexp/2$ may not be an integer, therefore some odd/even analysis is in order.</p><p>Note the following:</p><span>\begin{aligned}&1 \leq 1 + \ffrac &lt; 2 \\
\implies& 0 \leq \lg(1 + \ffrac) &lt; 1 \\
\implies& 0 \leq \frac{\lg(1 + \ffrac)}{2} &lt; \frac{1}{2} \tag{1}\end{aligned}</span><h4 id=odd-case>Odd case</h4><p>Assume that $\fexp$ is odd:</p><span>\begin{aligned}&\floor{-\frac{\fexp}{2} - \frac{\lg(1 + \ffrac))}{2}} \\
=&\floor{\floor{-\frac{\fexp}{2}} + \frac{1}{2} - \frac{\lg(1 + \ffrac))}{2}} \\
=&\floor{-\frac{\fexp}{2}}\qquad\qquad\qquad\qquad(\text{from }(1))\\
=&-\frac{\fexp}{2} - \frac{1}{2}\qquad\qquad\qquad(\fexp\text{ is odd}) \\
=&-\frac{\fexp + 1}{2}\end{aligned}</span><p>Note that $\fexp + 1$ is even, and therefore $-\dfrac{\fexp + 1}{2}$ is a valid exponent for IEEE-754.</p><h4 id=even-cases>Even cases</h4><p>Now assume that $\fexp$ is even. Therefore $\dfrac{\fexp}{2}$ is indeed an integer.
However, there are two cases to deal with: $\ffrac = 0$ and $\ffrac \neq 0$. If $\ffrac = 0$ then:</p><span>\[\floor{- \frac{\fexp}{2} - \frac{\lg(1 + \ffrac))}{2}} \\[0.2em]
=-\frac{\fexp}{2}\]</span><p>On the other hand, if $\ffrac \neq 0$ then :</p><span>\[\floor{- \frac{\fexp}{2} - \frac{\lg(1 + \ffrac))}{2}} \\[0.2em]
=-\frac{\fexp}{2} - 1 \\[0.2em]
=-\frac{\fexp + 2}{2}\]</span><h3 id=putting-it-together>Putting it together</h3><p>Let&rsquo;s recap. Let $r_\fexp$ denote the floating point exponent for the result. We have three cases:</p><span>\[r_\fexp = \begin{cases}
-\frac{\fexp + 1}{2} &\text{if } \fexp \text{ is odd } \\
-\frac{\fexp}{2} &\text{if } \fexp \text{ is even and } \ffrac = 0 \\
-\frac{\fexp + 2}{2} &\text{if } \fexp \text{ is even and } \ffrac \neq 0 \\
\end{cases}\]</span><p>Now we can directly determine what the exponent should be for the result. What is especially cool
about this is that no square roots or divisions are needed to do this &ndash; just an addition and a right shift!</p><p>On that note, a right shift can be thought of as being the floor of division by 2. Let&rsquo;s see what would happen if we implemented
the division by 2 in the formula above using a right shift. First, assume $\fexp$ is odd. Then:</p><span>\[ \floor{-\frac{\fexp + 1}{2}} = \frac{\fexp + 1}{2}
\]</span><p>Nothing changes here! Now if $\fexp$ is even, things get interesting:</p><span>\begin{aligned} &\floor{-\frac{\fexp + 1}{2}} \\
=& \floor{-\frac{\fexp}{2} - \frac{1}{2}} \\
=& -\frac{\fexp}{2} - 1 \\
=& -\frac{\fexp + 2}{2}
\end{aligned}</span><p>Our <em>even</em> and $\ffrac \neq 0$ case! Unfortunately $\floor{-\frac{0 + 1}{2}} = -1$, so this won&rsquo;t work for the even and $\ffrac = 0$ case.</p><p>So $r_\fexp$ simplifies to:</p><span>\[r_\fexp = \begin{cases}
\floor{-\dfrac{\fexp + 1}{2}} &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.75em]
-\dfrac{\fexp}{2} &\text{if } \fexp \text{ is even and } \ffrac = 0
\end{cases}\]</span><h3 id=biasing-the-exponent>Biasing the exponent</h3><span>\[\newcommand{\biased}[1]{\mathrm{biased}(#1)}\]</span><p>But remember, we still need to bias the exponent to form a proper <code>float64</code>. That means we need to add the value $1023$ to it.
Let <span>\(\biased{x} = x + 1023\)</span> denote an exponent $x$ biased by $1023$. We have two cases:</p><span>\[\biased{r_\fexp} = \begin{cases}
\floor{-\frac{\fexp + 1}{2}} + 1023 &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.2em]
-\frac{\fexp}{2} + 1023 &\text{if } \fexp \text{ is even and } \ffrac = 0 \\[0.2em]
\end{cases}\]</span><p>And, notice we can replace $\fexp$ with its biased form as well, leading us to:</p><span>\[\biased{r_\fexp} = \begin{cases}
\floor{-\frac{\biased{\fexp} - 1023 + 1}{2}} + 1023 &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.2em]
-\frac{\biased{\fexp} - 1023}{2} + 1023 &\text{if } \fexp \text{ is even and } \ffrac = 0
\end{cases}\]</span><p>Simplifying to:</p><span>\[\biased{r_\fexp} = \begin{cases}
\floor{\frac{3068 - \biased{\fexp}}{2}} &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.5em]
\frac{3069 - \biased{\fexp}}{2} &\text{if } \fexp \text{ is even and } \ffrac = 0
\end{cases}\]</span><p>Now, let&rsquo;s write the constants in hex notation for clarity:</p><span>\[\biased{r_\fexp} = \begin{cases}
\floor{\frac{\mathrm{0xBFC} - \biased{\fexp}}{2}} &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.5em]
\frac{\mathrm{0xBFD} - \biased{\fexp}}{2} &\text{if } \fexp \text{ is even and } \ffrac = 0
\end{cases}\]</span><p>Hey, wait a minute! That looks a <em>lot</em> like the <code>0xBFC</code> constant in the code, doesn&rsquo;t it?! Revisiting the code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span></span></span></code></pre></div><p>Let&rsquo;s break this apart. <code>param.4_4</code> is Ghidra notation for the upper 32-bits of our input <code>float64</code>, which looks like this:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>eeeeeeeeeee</span> <span class=kt>mmmmmmmmmmmmmmmmmmmmmmmmm</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>So <code>param_1._4_4_ >> 0x14</code> translates to &ldquo;shift the upper 32 bits of the float64 right 20 bits&rdquo;, meaning &ldquo;strip out the mantissa bits&rdquo;, leaving us with only the exponent bits:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm>00000000000000000000 <span class=mf>0</span>     <span class=k>eeeeeeeeeee</span>
                     ^     ^
                     sign  exponent</code></pre></div><p>Therefore:</p><ul><li><code>param_1._4_4_ >> 0x14</code> = $\biased{\fexp}$ and</li><li><code>0xbfc - (param_1._4_4_ >> 0x14)</code> $ = \mathrm{0xBFC} - \biased{\fexp}$.</li></ul><p>Next, the right shift. This is equivalent to floored division by 2, meaning:</p><p><code>0xbfc - (param_1._4_4_ >> 0x14) >> 1</code> $= \floor{\dfrac{\mathrm{0xBFC} - \biased{\fexp}}{2}}$, our first case.</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm>00000000000000000000 <span class=mf>0</span>     <span class=k>0rrrrrrrrrr</span>
                     ^     ^
                     sign  exponent</code></pre></div><p>Next, this is shifted back to line up with the exponent field with <code>(0xbfc - (param_1._4_4_ >> 0x14) >> 1) &lt;&lt; 0x14</code>, giving us the following upper 32 bits of a <code>float64</code>:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>0rrrrrrrrrr</span> <span class=kt>0000000000000000000000000</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>Branching on the CPU <a href=#ieee-x87>was likely expensive</a> back in 1997, so avoiding branches was critical for writing performant code.
There are a number of ways to do this. To keep it simple, they chose to hard code one path here, always selecting the first case. It was probably
chosen probabilistically, because the first case covers the vast majority if possible inputs. And besides, this is just supposed to be an
initial guess anyway &ndash; it doesn&rsquo;t need to be perfect. Later, we&rsquo;ll see how the effects of this are mitigated in the generation of the lookup table.</p><p>Let $c_\fexp$ denote our chosen exponent that approximates $r_\fexp$ for our initial guess:</p><span>\[c_\fexp = \floor{-\frac{\fexp + 1}{2}} \approx r_\fexp\]</span><p>We have now solved for the exponent bits of our initial guess and placed them in their correct positions.</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>0rrrrrrrrrr</span> <span class=kt>??????????????????????????🔒?????????????????????????</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>Making progress! Just one more field to go.</p><h3 id=rsqrt-guess-mantissa>The Mantissa</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class="line hl"><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class="line hl"><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Let&rsquo;s take what we learned about the exponent and imagine if we took the reciprocal square root of $v$.
What would it look like?</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} \\[0.2em]
= \frac{1}{\sqrt{2^\fexp(1 + \ffrac)}} \\[0.2em]
= \frac{1}{\sqrt{2^\fexp}\sqrt{1 + \ffrac}} \\[0.2em]
= 2^{-\fexp/2}\frac{1}{\sqrt{1 + \ffrac}}\]</span><p>Now this is interesting.
First, observe the following about: $\dfrac{1}{\sqrt{1 + \ffrac}}$:</p><span>\begin{aligned}&0 \leq \ffrac &lt; 1 \\
\iff& 1 \leq 1 + \ffrac &lt; 2 \\
\iff& 1 \leq \sqrt{1 + \ffrac} &lt; \sqrt{2} \\
\iff& \frac{1}{\sqrt{2}} &lt; \frac{1}{\sqrt{1 + \ffrac}} \leq 1 \tag{1}\end{aligned}</span><p>So by itself, this is not a suitable mantissa, because it doesn&rsquo;t fit in the range of $[1, 2)$.
However, we know the exponent isn&rsquo;t quite right either, according to the cases we&rsquo;ve explored in the previous section.
Let&rsquo;s fix that and break this out on the cases outlined previously:</p><h4 id=fexp-is-odd>$\fexp$ is odd</h4><p>In this case, the floating point exponent of the result is $\floor{-\dfrac{\fexp + 1}{2}} = -\dfrac{\fexp + 1}{2}$. Let&rsquo;s work backwards to get there:</p><span>\begin{aligned}&2^{-\fexp/2}\frac{1}{\sqrt{1 + \ffrac}} \\
=&2^{-\fexp/2 - 1/2 + 1/2}\frac{1}{\sqrt{1 + \ffrac}} \\
=&2^{-\fexp/2 - 1/2}\frac{\sqrt{2}}{\sqrt{1 + \ffrac}} \\
=&2^{-(\fexp + 1)/2}\frac{\sqrt{2}}{\sqrt{1 + \ffrac}} \\
=&2^{\floor{-(\fexp + 1)/2}}\frac{\sqrt{2}}{\sqrt{1 + \ffrac}}\end{aligned}</span><p>Note that, from $(1)$</p><span>\begin{aligned}& \frac{1}{\sqrt{2}} &lt; \frac{1}{\sqrt{1 + \ffrac}} \leq 1 \\
\iff& 1 &lt; \frac{\sqrt{2}}{\sqrt{1 + \ffrac}} \leq \sqrt{2} \\
\implies& 1 \leq \frac{\sqrt{2}}{\sqrt{1 + \ffrac}} &lt; 2\end{aligned}</span><p>A valid mantissa! This we can work with. If we choose:</p><span>\[m = \frac{\sqrt{2}}{\sqrt{1 + \ffrac}} - 1\]</span><p>Since $0 &lt; m &lt; 1$ and $\fexp + 1$ is even, then:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} = 2^{\floor{-(\fexp + 1)/2}}(1+m)\]</span><p>is the correct IEEE-754 floating point decomposition for the reciprocal square root of $\mathrm{fl}[v]$, with $m$ being the fractional part of its mantissa. Therefore have solved the mantissa for the odd case.
Next we will address the even cases.</p><h4 id=fexp-is-even-and-ffrac--0>$\fexp$ is even and $\ffrac = 0$</h4><p>Here, we know the floating point exponent of the result is $-\dfrac{\fexp}{2}$. Since $\ffrac = 0$, we already
know the mantissa of the result will be $1$:</p><span>\begin{aligned}&2^{-\fexp/2}\frac{1}{\sqrt{1 + \ffrac}} \\
=&2^{-\fexp/2}\frac{1}{\sqrt{1 + 0}} \\
=&2^{-\fexp/2}\end{aligned}</span><p>That was easy! Therefore, if we let $m = 0$, then</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} = 2^{-\fexp/2}(1+m)\]</span><p>is the correct IEEE-754 floating point decomposition for the reciprocal square root of $\mathrm{fl}[v]$, with $m$ being the fractional part of its mantissa.</p><h4 id=fexp-is-even-and-ffrac-neq-0>$\fexp$ is even and $\ffrac \neq 0$</h4><p>First, we know our exponent is $\floor{-\dfrac{\fexp + 1}{2}} = -\dfrac{\fexp + 2}{2}$.</p><p>Let&rsquo;s work backwards once again:</p><span>\begin{aligned}&2^{-\fexp/2}\frac{1}{\sqrt{1 + \ffrac}} \\
=&2^{-\fexp/2 - 1 + 1}\frac{1}{\sqrt{1 + \ffrac}} \\
=&2^{-\fexp/2 - 1}\frac{2}{\sqrt{1 + \ffrac}} \\
=&2^{-(\fexp + 2)/2}\frac{2}{\sqrt{1 + \ffrac}} \\
=&2^{\floor{-(\fexp + 1)/2}}\frac{2}{\sqrt{1 + \ffrac}}\end{aligned}</span><p>Now here, $\ffrac \neq 0$, so $(1)$ simplifies to:</p><span>\[\frac{1}{\sqrt{2}} &lt; \frac{1}{\sqrt{1 + \ffrac}} &lt; 1\]</span><p>This is important because we can now scale it to get a valid mantissa:</p><span>\begin{aligned}& \frac{1}{\sqrt{2}} &lt; \frac{1}{\sqrt{1 + \ffrac}} &lt; 1 \\
\iff& \sqrt{2} &lt; \frac{2}{\sqrt{1 + \ffrac}} &lt; 2 \\
\implies& 1 \leq \frac{2}{\sqrt{1 + \ffrac}} &lt; 2 \end{aligned}</span><p>Therefore, if we set</p><span>\[m = \frac{2}{\sqrt{1 + \ffrac}} - 1\]</span><p>Then $0 \leq m &lt; 1$ and:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} = 2^{\floor{-(\fexp + 1)/2}}(1 + m)\]</span><p>is the correct IEEE-754 floating point decomposition for the reciprocal square root of $\mathrm{fl}[v]$, with $m$ being the fractional part of its mantissa!
We have now solved for the mantissa for all cases.</p><h3 id=exact-decomposition-of-the-reciprocal-square-root>Exact decomposition of the reciprocal square root</h3><p>Let $r_\ffrac$ denote the fractional part of the mantissa for the result. Recall:</p><span>\[r_\fexp = \begin{cases}
\floor{-\dfrac{\fexp + 1}{2}} &\text{if } \fexp \text{ is odd, or } \fexp\text{ is even and } \ffrac \neq 0 \\[0.75em]
-\dfrac{\fexp}{2} &\text{if } \fexp \text{ is even and } \ffrac = 0
\end{cases}\]</span><p>is the exponent for the result. There are three cases for the fractional part of the mantissa:</p><span>\[r_\ffrac = \begin{cases}
\dfrac{\sqrt{2}}{\sqrt{1 + \ffrac}} - 1 &\text{if } \fexp \text{ is odd } \\
0 &\text{if } \fexp \text{ is even and } \ffrac = 0 \\
\dfrac{2}{\sqrt{1 + \ffrac}} - 1 &\text{if } \fexp \text{ is even and } \ffrac \neq 0
\end{cases}\]</span><p>Therefore:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} = 2^{r_\fexp}(1 + r_\ffrac)\]</span><p>is the exact IEEE-754 floating point decomposition of the reciprocal square root of $\mathrm{fl}[v]$ without any approximations.</p><p>With the groundwork now laid out, we can now go about cutting corners &ndash; err, constructing an approximation of $r_\ffrac$ using a lookup table.</p><h3 id=approximating-the-fexp-is-even-and-ffrac--0-case>Approximating the &ldquo;$\fexp$ is even and $\ffrac = 0$&rdquo; case</h3><p>As noted previously, the code chooses the exponent as follows:</p><span>\[c_\fexp = \floor{-\frac{\fexp + 1}{2}}\]</span><p>When $\fexp$ is odd or $fexp$ is even and $\ffrac \neq 0$, this is equivalent to $r_\fexp$. However, when $\fexp$ is even and $\ffrac = 0$,
$c_\fexp = r_\fexp - 1$, i.e., one lower than the correct result.
It is possible to compensate for this choice by choosing a different mantissa for this case.</p><p>Choose an $m, 0 \leq m &lt; 1$ that is as close to $1$ as is possible. Then $1 + m \approx 2$ and:</p><span>\[2^\floor{-(\fexp + 1)/2}(1 + m) = 2^{-\fexp/2 - 1}(1 + m) \approx 2^{-\fexp/2 - 1}(2) = 2^{-\fexp/2} = \frac{1}{\sqrt{\mathrm{fl}[v]}}\]</span><p>Which gets us closer to where we want to be. The closer $m$ gets to $1$, the better the approximation will be &ndash; but note it can never actually reach $1$.
The actual choice of $m$ in practice will be limited by the precision dependent bounds of the actual floating point type.
As we&rsquo;ll see later, it is possible to choose such an $m$ directly within the lookup table, avoiding all overhead.</p><p>Therefore, for a suitable $m$ close to $1$:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} \approx 2^{\floor{-(\fexp + 1)/2}}(1+m)\]</span><p>is an <em>approximate</em> IEEE-754 floating point decomposition for the reciprocal square root of $\mathrm{fl}[v]$ for this case, with $m$ being the fractional part of its mantissa.</p><h4 id=approximating-r_ffrac-when-choosing-c_fexp-as-the-exponent>Approximating $r_\ffrac$ when choosing $c_\fexp$ as the exponent</h4><p>Let $c_\ffrac$ denote the chosen fractional part of the mantissa for the initial guess with chosen exponent $c_\fexp$:</p><span>\[c_\ffrac = \begin{cases}
\dfrac{\sqrt{2}}{\sqrt{1 + \ffrac}} - 1 &\text{if } \fexp \text{ is odd } \\
\text{A constant close to }1 &\text{if } \fexp \text{ is even and } \ffrac = 0 \\
\dfrac{2}{\sqrt{1 + \ffrac}} - 1 &\text{if } \fexp \text{ is even and } \ffrac \neq 0
\end{cases}\]</span><p>Therefore:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} \approx 2^{c_\fexp}(1 + c_\ffrac)\]</span><p>is an <em>approximate</em> IEEE-754 floating point decomposition for the reciprocal square root of $\mathrm{fl}[v]$.</p><h4 id=approximating-c_ffrac-using-a-lookup-table>Approximating $c_\ffrac$ using a lookup table</h4><p>As this is just supposed to be an initial guess, it&rsquo;s perfectly fine to not have all of the mantissa bits be correct.
We just want to land somewhere <em>near</em> where we should be with the guess.</p><p>Notice that $c_\ffrac$ only depends on $\fexp$ for selecting the right case. Otherwise, it is characterized
entirely in terms of $\ffrac$. In fact, we only need the least significant bit of $\fexp$ to select the right case.
If the least significant bit of $\fexp$ is set, then it is odd, otherwise it is even.</p><p>Recall that if $\fexp$ is even $ \iff \biased{\fexp}$ is odd.
Let $r$ be the least significant bit of $\biased{\fexp}$. Then $c_\ffrac$ simplifies to:</p><span>\[c_\ffrac = \begin{cases}
\text{A constant close to }1 &\text{if } \biased{\fexp} \text{ is odd and } \ffrac = 0 \\
\dfrac{\sqrt{2}^{r + 1}}{\sqrt{1 + \ffrac}} - 1&\text{otherwise}
\end{cases}\]</span><p>Approximating things is almost always achieved by throwing away information.
We have an exact decomposition of the result at our disposal, but we don&rsquo;t need this to compute a guess.</p><p>Let:</p><span>\[\newcommand{\truncate}[2]{\mathrm{truncate}_{#1}(#2)}
\newcommand{\round}[2]{\mathrm{round}_{#1}(#2)}
\newcommand{\msb}[2]{\mathrm{msb}_{#1}(#2)}
\msb{n}{x} = \floor{2^nx}\]</span>
<span>\[\truncate{n}{x} = \frac{\msb{n}{x}}{2^n}\]</span><p>So for $0 \leq x &lt; 1$, $\msb{n}{x}$ denotes the most significant $n$ bits of $x$ as an integer, truncating all remaining bits.</p><p>For $0 \leq x &lt; 1$, $\truncate{n}{x}$ is $x$ with only it&rsquo;s most significant $n$ bits kept, all other bits zeroed out.
In other words, $x$ is truncated to fit within $n$ bits.</p><p>Let&rsquo;s truncate $\ffrac$ to fit within 7 bits:</p><span>\[\ffrac \approx \truncate{7}{\ffrac}\]</span><p>And let&rsquo;s define $M$, an approximation of $c_\ffrac$ using the truncated $\ffrac$:</p><span>\[M = \begin{cases}
\dfrac{2^8 - 1}{2^8} &\text{if } \biased{\fexp} \text{ is odd and } \ffrac = 0 \\
\round{8}{\dfrac{\sqrt{2}^{r + 1}}{\sqrt{1 + \truncate{7}{\ffrac}}} - 1} &\text{otherwise}
\end{cases}\]</span><p>Note that $\dfrac{2^8 - 1}{2^8}$ is the closest possible value to $1$ that we can choose with only 8 significant bits.
$\round{8}{x}$ can be any rounding method you want that rounds $x$ to fit within 8 bits. We&rsquo;ll explore the choice used in the code later.</p><p>Then $M \approx c_\ffrac \approx r_\ffrac$ and:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[v]}} \approx 2^{c_\fexp}(1 + M)\]</span><p>Now, $M$ is sensitive to only 8 bits of $v$: the least significant bit of the exponent (for case selection) and the 7 most significant bits of the mantissa.
Since M only has 8 bits of precision, it can be stored as a finite value in a lookup table, and since it is only sensitive to 8 bits of the input,
that means that lookup table would only have $2^8$ entries. We could address such a table with the following formula (0-indexed):</p><span>\[\mathrm{LUT}[2^7r + \msb{7}{\ffrac}] = M \approx c_\ffrac \approx r_\ffrac\]</span><p>The problematic &ldquo;$\fexp$ is even and $\ffrac = 0$&rdquo; maps to $\mathrm{LUT}[2^7]$ here ($r = 1$ because $\biased{\fexp}$ is odd, and all bits of $\ffrac$ are 0), which by the definition of $M$ stores $\dfrac{2^8 - 1}{2^8}$. This provides a unified formula to approximate the mantissa for all cases.</p><p>Generating this lookup table will be examined in more detail in the next section.</p><p>Therefore, we can use a lookup table to determine the mantissa bits for the guess based on the least significant bit
of the biased exponent and the 7 most significant bits of the mantissa field. In practice, this looks like a <code>float64</code> indexed by the following bits:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>eeeeeeeeee[e</span> <span class=kt>mmmmmmm]mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span>
^     ^            ^
sign  exponent     mantissa</code></pre></div><h4 id=lut-generation-analysis>LUT Generation Analysis</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>generate_lut</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>local_10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class="line hl"><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class="line hl"><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class="line hl"><span class=cl>    <span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span>
</span></span><span class="line hl"><span class=cl>      <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>SQRT</span><span class=p>((</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)((</span><span class=n>uVar1</span> <span class=o>|</span> <span class=mh>0x1ff00U</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0xd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)))</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class="line hl"><span class=cl>    <span class=n>global_lut</span><span class=p>[</span><span class=n>uVar1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>byte</span><span class=p>)(</span><span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>);</span>
</span></span><span class="line hl"><span class=cl>    <span class=n>uVar1</span> <span class=o>=</span> <span class=n>uVar1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class="line hl"><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>uVar1</span> <span class=o>&lt;</span> <span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>global_lut</span><span class=p>[</span><span class=mi>128</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This function generates the lookup table $\mathrm{LUT}$ discussed in the previous section. It has 256 entries each
containing 8 bits of mantissa, for a total of 256 bytes.
In the code above, <code>uVar1</code> iterates from 0 to 256, covering the entire lookup table.</p><p>First, the fragment:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)((</span><span class=n>uVar1</span> <span class=o>|</span> <span class=mh>0x1ff00U</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0xd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span></span></span></code></pre></div><p>Note the cast to <code>double</code> is not quite right here &ndash; it&rsquo;s a bitwise cast, not a static cast, being performed. Here&rsquo;s a C++ version that better illustrates what&rsquo;s going on:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>float64bits</span> <span class=o>=</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>|</span> <span class=n>UINT64_C</span><span class=p>(</span><span class=mh>0x1ff00</span><span class=p>))</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=k>const</span> <span class=n>d</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>float64bits</span><span class=p>);</span></span></span></code></pre></div><p>In other words, a <code>float64</code> is constructed directly using its bitwise representation.
To visualize, this is the <code>float64</code> constructed by <code>or</code>ing the loop counter with <code>0x1ff00</code> and shifting by <code>0x2d</code>:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>1111111111[e</span> <span class=kt>mmmmmmm]000000000000000000000000000000000000000000000</span>
^     ^            ^
sign  exponent     mantissa</code></pre></div><p>This means the loop counter is filling the least significant bit of the biased exponent and the most significant 7 bits of the mantissa field!
The loop index iterates from <code>0</code> to <code>0xFF</code> inclusive, which means:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>|</span> <span class=n>UINT64_C</span><span class=p>(</span><span class=mh>0x1ff00</span><span class=p>)</span></span></span></code></pre></div><p>ranges from <code>0x1ff00</code> to <code>0x1ffff</code> inclusive. Now, <code>0x1ff00 &lt;&lt; 0x2d</code> evaluates to <code>0x3fe0000000000000</code>,
or the <code>float64</code> value $0.5$. On the other hand, <code>0x1ffff &lt;&lt; 0x2d</code> evaluates to <code>0x3fffe00000000000</code>, or the <code>float64</code> value $1.9921875$.</p><p>Together, this paints a picture: the lookup table is generated by iterating over the range of $[0.5,2)$. The lower half of the table
covers the range of $[0.5, 1)$, and the upper half covers the range of $[1, 2)$:</p><ul><li>$[0.5, 1)$ is iterated with an interval of 0.00390625 (when the biased exponent is even) (128 entries)</li><li>$[1, 2)$ is iterated with an interval of 0.0078125 (when the biased exponent is odd) (128 entries)</li></ul><p>Next, the reciprocal square root is evaluated on this newly constructed <code>float64</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>SQRT</span><span class=p>((</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)((</span><span class=n>uVar1</span> <span class=o>|</span> <span class=mh>0x1ff00U</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0xd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)))</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span></span></span></code></pre></div><p><code>var1</code> is a double, and <code>var1._4_4_</code> is Ghidra notation for &ldquo;the upper 32 bits of the double as an integer&rdquo;. So what this refers to are the high 32 bits
of the reciprocal square root result. This is better illustrated with the following fragment of C++:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=k>const</span> <span class=n>rsqrt</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>u64rsqrt</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rsqrt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=k>const</span> <span class=n>high32bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>u64rsqrt</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span></span></span></code></pre></div><p>As discussed, $M$ is sensitive to only 8 bits of the input: the 7 most significant bits of the mantissa field and the
least significant bit of the biased exponent of the input $v$.</p><p>Let&rsquo;s examine what this is for the lower half of the table. This means the reciprocal square root of a value in $x \in [0.5, 1)$ is taken.
Let $x = 2^{-1}(1 + p)$ be the floating point decomposition of $x$, with $p = \truncate{7}{p}$ due to the bit pattern generated above from the loop counter. Then according to our exact decomposition rules:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[x]}} = 2^\floor{-(-1 + 1)/2}\frac{\sqrt{2}}{\sqrt{1 + p}} = 2^0\frac{\sqrt{2}}{\sqrt{1 + \truncate{7}{p}}}\]</span><p>In other words, the fractional part of the mantissa is just $\dfrac{\sqrt{2}}{\sqrt{1 + \truncate{7}{p}}} - 1$.</p><p>On the other hand, for the upper half of the table, let $x \in (1, 2)$ (to exclude $x = 1$ for now), with $p = \truncate{7}{p}$ due to the bit pattern as generated from the loop counter:</p><span>\[\frac{1}{\sqrt{\mathrm{fl}[x]}} = 2^\floor{-(0 + 1)/2}\frac{2}{\sqrt{1 + p}} = 2^{-1}\frac{2}{\sqrt{1 + p}} = 2^{-1}\frac{2}{\sqrt{1 + \truncate{7}{p}}}\]</span><p>In other words, the fractional part of the mantissa is just $\dfrac{2}{\sqrt{1 + \truncate{7}{p}}} - 1$.</p><p>Unifying these, let $x \in [0.5,1) \cup (1, 2)$ (excluding $1$). Let $r$ be the least significant bit of the biased exponent for $x$. Then
the fractional part of the mantissa is:</p><span>\[\frac{\sqrt{2}^{r + 1}}{\sqrt{1 + \truncate{7}{p}}} - 1\]</span><p>This means that the mantissa field of the result of the reciprocal square root will have an approximation of these values in either case.
If we round this, it corresponds perfectly to $M$ given this input as discussed in the previous section:</p><span>\[\round{8}{\frac{\sqrt{2}^{r + 1}}{\sqrt{1 + \truncate{7}{p}}} - 1}\]</span><h5 id=rounding>Rounding</h5><p>In the code, <code>var1._4_4_ + 0x400</code> appears to be attempting to round the mantissa according to the &ldquo;<em>round half-up</em>&rdquo; rule. However, I think this may be a bug.
<a href=https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero>Round half-up</a> is round to nearest, resolving ties upwards. This is the same rounding we all learned in school.<br>You could think of this as adding half a <a href=https://en.wikipedia.org/wiki/Unit_in_the_last_place>unit in the last place (ULP)</a> to the value and then truncating.
So, if we wanted to correctly round $0 \leq x &lt; 1$ using this method to 8 fractional bits of mantissa, we would do the following:</p><span>\[\round{8}{x} = \truncate{8}{x + 2^{-9}}\]</span><p>In other words, we&rsquo;d add &ldquo;half&rdquo; of the column of $2^{-8}$ to $x$ and then truncate the result.
For illustrative purposes, these are the upper 32 bits of the <code>float64</code> result, adding $2^{-9}$ for the first step of the rounding:</p><pre tabindex=0><code>  0eee eeee eeee mmmm mmmm mmmm mmmm mmmm
+ 0000 0000 0000 0000 0000 1000 0000 0000 (0x800)
  ---------------------------------------
</code></pre><p>This corresponds to the constant <code>0x800</code> being added to the upper 32 bits of the <code>float64</code>, treating it as an integer.
But that&rsquo;s not what&rsquo;s going on in the code! They add <code>0x400</code> instead of <code>0x800</code>, which looks like:</p><pre tabindex=0><code>  0eee eeee eeee mmmm mmmm mmmm mmmm mmmm
+ 0000 0000 0000 0000 0000 0100 0000 0000 (0x400)
  ---------------------------------------
</code></pre><p>Which would round to nearest, ties upwards to 9 bits, not 8 bits of mantissa. After thinking about this for a bit, I believe this is a bug and that
the correct constant should be <code>0x800</code>. Note that it never actually carries into the exponent field &ndash; although if it did, we&rsquo;d have to re-normalize the float.</p><p>After this, the 8 most significant bits of the mantissa field are stored in the LUT, effectively truncating the mantissa:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=n>global_lut</span><span class=p>[</span><span class=n>uVar1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>byte</span><span class=p>)(</span><span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>);</span></span></span></code></pre></div><p>We can interpret this as being the value:</p><span>\[\round{8}{\frac{\sqrt{2}^{r + 1}}{\sqrt{1 + \truncate{7}{p}}}}\]</span><p>Now, <code>uVar1</code> is the loop counter, and $x$ is the <code>float64</code> generated by <code>0x1ff00 | uVar1 &lt;&lt; 0x2d</code>. This means
the most significant bit of <code>uVar1</code> corresponds to $r$, and the rest are the most significant bits of the mantissa.
Therefore, <code>global_lut[uVar1]</code> corresponds exactly to the entry $\mathrm{LUT}[2^7r + \msb{7}{p}]$,
and the above fragment is semantically equivalent to:</p><span>\[\mathrm{LUT}[2^7r + \msb{7}{p}] = \round{8}{\frac{\sqrt{2}^{r + 1}}{\sqrt{1 + \truncate{7}{p}}}}\]</span><p>Note that entries <code>global_lut</code> is implicitly treated as being divided by <code>2^8</code>, because they store the 8 most significant
bits of the fractional part of the mantissa. But there is one last thing to deal with! Handling the &ldquo;even and $\ffrac = 0$&rdquo; case:</p><h5 id=lut-fixup>LUT fixup</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>generate_lut</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>local_10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>SQRT</span><span class=p>((</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)((</span><span class=n>uVar1</span> <span class=o>|</span> <span class=mh>0x1ff00U</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0xd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)))</span> <span class=o>&gt;&gt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>global_lut</span><span class=p>[</span><span class=n>uVar1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>byte</span><span class=p>)(</span><span class=n>var1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>&gt;&gt;</span> <span class=mh>0xc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uVar1</span> <span class=o>=</span> <span class=n>uVar1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>uVar1</span> <span class=o>&lt;</span> <span class=mh>0x100</span><span class=p>);</span>
</span></span><span class="line hl"><span class=cl>  <span class=n>global_lut</span><span class=p>[</span><span class=mi>128</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We can see the fixup we have discussed previously marked above.
<code>global_lut[128]</code> corresponds exactly to $\mathrm{LUT}[2^7]$ which is our &ldquo;even and $\ffrac = 0$&rdquo; case.
Setting it to <code>0xff</code> then is equivalent to setting $\mathrm{LUT}[2^7] = \dfrac{2^8 - 1}{2^8}$, completing
the fixup. This concludes handling the &ldquo;even and $\ffrac = 0$&rdquo; case.</p><h4 id=lut-indexing>LUT Indexing</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class="line hl"><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Putting together what we&rsquo;ve learned, the lookup table is indexed directly using the bits discussed from the input
get the mantissa bits for the guess:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>eeeeeeeeee[e</span> <span class=kt>mmmmmmm]mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</span>
^     ^            ^
sign  exponent     mantissa</code></pre></div><p>This is better illustrated with the following C++ fragment:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>scalar_bits</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>scalar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=k>const</span> <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>scalar_bits</span> <span class=o>&gt;&gt;</span> <span class=mh>0x2d</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//LUT[index] contains the 8 most significant bits of the mantissa, rounded.
</span></span></span><span class=line><span class=cl><span class=c1>//Treat all lower 44 bits as zeroed out
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>mantissa_bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>LUT</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2c</span><span class=p>;</span></span></span></code></pre></div><p>In other words, the lower 44 bits of the input&rsquo;s mantissa are completely ignored, and the 7 most significant fractional mantissa bits,
combined with the least significant bit of the biased exponent, are used to pick an approximation of the mantissa rounded to 8 bits.
This is most accurate when the lower 44 bits of the mantissa are already zeroed out and it&rsquo;s not the &ldquo;even and $\ffrac = 0$&rdquo; case,
and is the least accurate when all lower 44 bits are set. But this is just a guess, so we can live with it!</p><p>Now we&rsquo;re talking:</p><div class=highlight><pre class=chroma><code class=language-nasm data-lang=nasm><span class=mf>0</span>     <span class=k>0eeeeeeeeee</span> <span class=kt>mmmmmmmm00000000000000000000000000000000000000000000</span>
^     ^           ^
sign  exponent    mantissa</code></pre></div><p>We have just constructed the initial guess! Now to use it to get a much better approximation.</p><h2 id=rsqrt-newton>Newton-Raphson iteration</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class="line hl"><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class="line hl"><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Next, one iteration of <a href=https://en.wikipedia.org/wiki/Newton%27s_method>Newton-Raphson</a> is performed using the initial guess as previously computed.
This is exactly the same as what appears in the Quake 3 <code>Q_rsqrt</code> function. The formula derivation is as follows.</p><span>\[y = \frac{1}{\sqrt{v}}
\iff y^2 = \frac{1}{v}
\iff vy^2 = 1
\iff \frac{1}{y^2} = v
\iff \frac{1}{y^2} - v = 0\]</span><p>Let $f(y) = \frac{1}{y^2} - v$. If we can solve for $f(y) = 0$ for a given $v$ then $y$ is the reciprocal square root of $v$. The derivative of $f$ with respect to $y$ is:</p><span>\[f'(y) = -2y^{-3}\]</span><p>One iteration of Newton-Raphson is evaluated as follows:</p><span>\[y_1 = y_0 - \frac{f(y_0)}{f'(y_0)}\]</span><p>This simplifies to:</p><span>\[y_1 = \frac{(3 - y_0^2v)y_0}{2}\]</span><p>We evaluate $y_1$ by setting $y_0$ to the initial guess as computed earlier.</p><p>Looking at our decompiled code, we can see a direct implementation of this formula, but with with a strange extra multiplication of <code>1.00001</code> at the end&mldr;</p><h2 id=rsqrt-posthocfixup>Newton-Raphson fixup</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>uVar1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>float10</span> <span class=n>fVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>uVar1</span> <span class=o>=</span> <span class=p>(</span><span class=mh>0xbfc</span> <span class=o>-</span> <span class=p>(</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0x14</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x14</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>uint</span><span class=p>)</span><span class=n>global_lut</span><span class=p>[</span><span class=n>param_1</span><span class=p>.</span><span class=n>_4_4_</span> <span class=o>&gt;&gt;</span> <span class=mh>0xd</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mh>0xc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>fVar2</span> <span class=o>=</span> <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>double_3</span><span class=mf>.0</span> <span class=o>-</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=n>fVar2</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)(</span><span class=kt>double</span><span class=p>)((</span><span class=n>ulonglong</span><span class=p>)</span><span class=n>uVar1</span> <span class=o>&lt;&lt;</span> <span class=mh>0x20</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_0</span><span class=mf>.5</span> <span class=o>*</span>
</span></span><span class="line hl"><span class=cl>         <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=n>double_approx_1</span><span class=mf>.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Let&rsquo;s go back and try our <code>1.0</code> example again:</p><p><img src=unfixup.png alt></p><p>So we&rsquo;re pretty close with the LUT fixup, but notice we&rsquo;re still at <code>0.999942...</code>. It&rsquo;s not a dealbreaker, but it isn&rsquo;t really pleasing to look at either.
How can we fix that? Well, one way is to just apply another fixup &ndash; say, by scaling it up so it fits
better. It only needs to be accurate to within 4 decimal places, so what can we do? Multiply it by <code>1.00001</code>!</p><p><img src=fixup.png alt></p><p>That&rsquo;s better! Calling the function with <code>1.0</code> now gives you something that looks about right. Rounding this to 4 significant figures
produces the expected result.</p><p>You may be wondering why a multiplication was used and not an addition. I have a hunch this has to do with the <a href=https://matthew-brett.github.io/teaching/floating_error.html>error</a> of the function.
The absolute error will increase while the relative error should remain relatively bounded. Multiplication helps correct that
across the entire domain, while addition will have a very strong effect near $0$ and likely not any effect at all for large $v$.</p><h2 id=cleaned-up-i76_rsqrt>Cleaned up <code>i76_rsqrt</code></h2><p>Putting all this together, I present a much cleaned up C++20 version of the fast reciprocal square root code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=k>const</span> <span class=n>scalar</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>scalar_bits</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>scalar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=k>const</span> <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>scalar_bits</span> <span class=o>&gt;&gt;</span> <span class=mh>0x2d</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//LUT[index] is our mantissa, rounded up, all lower 34 bits zeroed out
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>mantissa_bits</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>LUT</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=o>&lt;&lt;</span> <span class=mh>0x2c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>exponent_bits</span> <span class=o>=</span> <span class=p>((</span><span class=mh>0xbfcUL</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar_bits</span> <span class=o>&gt;&gt;</span> <span class=mh>0x34</span><span class=p>))</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mh>0x34</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//exponent_bits has form 0xYYY00000 00000000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//mantissa_bits has form 0x000ZZ000 00000000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//so combined, we have   0xYYYZZ000 00000000 -- a complete float64 for the guess
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=k>const</span> <span class=n>combined_bits</span> <span class=o>=</span> <span class=n>exponent_bits</span> <span class=o>|</span> <span class=n>mantissa_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>initial_guess</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bit_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>combined_bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>half_initial_guess</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>initial_guess_squared</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=n>initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>newton_raphson</span> <span class=o>=</span> <span class=p>(</span><span class=mf>3.0</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar</span> <span class=o>*</span> <span class=n>initial_guess_squared</span><span class=p>))</span> <span class=o>*</span> <span class=n>half_initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=k>const</span> <span class=n>fixup</span> <span class=o>=</span> <span class=n>newton_raphson</span> <span class=o>*</span> <span class=mf>1.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fixup</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h5 id=rsqrt-asm-comparison>Assembly comparison</h5><p>Here&rsquo;s a comparison with the original function in the same vein as the LUT generation code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; original I&#39;76 rsqrt               | ; new code, clang 11 -Ofast -mno-sse -std=c++2b -m32 </span>
</span></span><span class=line><span class=cl>                                    <span class=err>|</span> <span class=nf>sub</span>     <span class=nb>esp</span><span class=p>,</span> <span class=mh>014h</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>ecx</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>        <span class=o>|</span> <span class=nv>fld</span>     <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span> <span class=o>+</span> <span class=mh>018h</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>edx</span><span class=p>,</span><span class=nv>BFC</span>                         <span class=o>|</span> <span class=nb>fs</span><span class=nv>t</span>     <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=nf>shr</span> <span class=nb>ecx</span><span class=p>,</span><span class=mi>14</span>                          <span class=o>|</span> <span class=nv>mov</span>     <span class=nb>eax</span><span class=p>,</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span> <span class=o>+</span> <span class=mh>0Ch</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>eax</span><span class=p>,</span><span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>        <span class=o>|</span> <span class=nv>mov</span>     <span class=nb>ecx</span><span class=p>,</span> <span class=nb>eax</span> 
</span></span><span class=line><span class=cl><span class=nf>shr</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>D</span>                           <span class=o>|</span> <span class=nv>shr</span>     <span class=nb>ecx</span><span class=p>,</span> <span class=mh>0Dh</span> 
</span></span><span class=line><span class=cl><span class=nf>sub</span> <span class=nb>edx</span><span class=p>,</span><span class=nb>ecx</span>                         <span class=o>|</span> <span class=nv>movzx</span>   <span class=nb>ecx</span><span class=p>,</span> <span class=nb>cl</span> 
</span></span><span class=line><span class=cl><span class=nf>shr</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>1</span>                           <span class=o>|</span> <span class=nv>movzx</span>   <span class=nb>ecx</span><span class=p>,</span> <span class=kt>byte</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>ecx</span> <span class=o>+</span> <span class=nv>LUT</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=nf>and</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>FF</span>                          <span class=o>|</span> <span class=nv>shl</span>     <span class=nb>ecx</span><span class=p>,</span> <span class=mh>0Ch</span> 
</span></span><span class=line><span class=cl><span class=nf>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>      <span class=o>|</span> <span class=nv>shr</span>     <span class=nb>eax</span> 
</span></span><span class=line><span class=cl><span class=nf>shl</span> <span class=nb>edx</span><span class=p>,</span><span class=mi>14</span>                          <span class=o>|</span> <span class=nv>and</span>     <span class=nb>eax</span><span class=p>,</span> <span class=mh>07FF80000h</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>al</span><span class=p>,</span><span class=kt>byte</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=nb>eax</span><span class=o>+</span><span class=mi>5</span><span class=nv>FB180</span><span class=p>]</span>     <span class=o>|</span> <span class=nv>mov</span>     <span class=nb>edx</span><span class=p>,</span> <span class=mh>05FE00000h</span>
</span></span><span class=line><span class=cl><span class=nf>shl</span> <span class=nb>eax</span><span class=p>,</span><span class=nv>C</span>                           <span class=o>|</span> <span class=nv>sub</span>     <span class=nb>edx</span><span class=p>,</span> <span class=nb>eax</span> 
</span></span><span class=line><span class=cl><span class=nf>xor</span> <span class=nb>ecx</span><span class=p>,</span><span class=nb>ecx</span>                         <span class=o>|</span> <span class=nv>and</span>     <span class=nb>edx</span><span class=p>,</span> <span class=mh>0FFF00000h</span>
</span></span><span class=line><span class=cl><span class=nf>or</span> <span class=nb>edx</span><span class=p>,</span><span class=nb>eax</span>                          <span class=o>|</span> <span class=nv>or</span>      <span class=nb>edx</span><span class=p>,</span> <span class=nb>ecx</span> 
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>],</span><span class=nb>ecx</span>        <span class=o>|</span> <span class=nv>mov</span>     <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span> <span class=o>+</span> <span class=mi>4</span><span class=p>],</span> <span class=nb>edx</span> 
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>dword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>8</span><span class=p>],</span><span class=nb>edx</span>        <span class=o>|</span> <span class=nv>mov</span>     <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=p>],</span> <span class=mi>0</span> 
</span></span><span class=line><span class=cl><span class=nf>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>      <span class=o>|</span> <span class=nv>fld</span>     <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>esp</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=nf>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                    <span class=o>|</span> <span class=nv>fld</span>     <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nf>fld</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ss</span><span class=p>:[</span><span class=nb>esp</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>      <span class=o>|</span> <span class=nv>fmul</span>    <span class=nv>st</span><span class=p>,</span> <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nf>fxch</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>                    <span class=o>|</span> <span class=nv>fmulp</span>   <span class=nv>st</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=nv>st</span> 
</span></span><span class=line><span class=cl><span class=nf>fmulp</span> <span class=nv>st</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                   <span class=o>|</span> <span class=nv>fxch</span>    <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nf>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501168</span><span class=p>]</span>    <span class=o>|</span> <span class=nb>fs</span><span class=nv>ubr</span>   <span class=kt>dword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nv>__real@40400000</span> <span class=p>(</span><span class=mh>08CF000h</span><span class=p>)]</span> 
</span></span><span class=line><span class=cl><span class=nf>fxch</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>                    <span class=o>|</span> <span class=nv>fxch</span>    <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nf>fsubr</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501160</span><span class=p>]</span>   <span class=o>|</span> <span class=nv>fmul</span>    <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nv>__real@3fe0000a7c5ac472</span> <span class=p>(</span><span class=mh>08CF008h</span><span class=p>)]</span> 
</span></span><span class=line><span class=cl><span class=nf>fmulp</span> <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>                   <span class=o>|</span> <span class=nv>fmulp</span>   <span class=nv>st</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=nv>st</span> 
</span></span><span class=line><span class=cl><span class=nf>fmul</span> <span class=nv>st</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=mi>501170</span><span class=p>]</span>    <span class=o>|</span> 
</span></span><span class=line><span class=cl>                                    <span class=err>|</span> <span class=nf>add</span>     <span class=nb>esp</span><span class=p>,</span> <span class=mh>014h</span>
</span></span><span class=line><span class=cl><span class=nf>ret</span>                                 <span class=o>|</span> <span class=nv>ret</span></span></span></code></pre></div><p>The code is far more readable <em>and</em> it seems to be about on par with the original!
The main difference here is that Clang <a href=#fp-assoc>reordered</a> the floating point operations (due to fast math optimizations)
and didn&rsquo;t clobber the argument passed on the stack, instead doing scratch work in newly
allocated memory. It does seem that it could do a better job if it wanted, but I&rsquo;m not complaining.</p><h2 id=analysis>Analysis</h2><p>Earlier I noted that the numerical error of this method repeats itself. It&rsquo;s plainly visible why this is the case now: the mantissa
itself depends on only one bit of the biased exponent. This means if you keep sampling <code>float64</code>s with the same mantissa,
you will get the same relative error!</p><p>In my quick experiments, this seems to give 4 significant digits of accuracy in the worst case, which is not too bad.</p><p>Note that the LUT entries could be extended to give more precision, but because the input mantissa precision is
already truncated to 7 bits, it&rsquo;s doubtful this would meaningfully effect the relative error. You <em>could</em> add
more entries to the LUT by indexing more mantissa bits, but each additional bit you add will double the size of the LUT.
That could have negative effects on the cache, which is very important in hot code such as this.</p><h2 id=patching-the-game>Patching the game</h2><p>Now, let&rsquo;s put our theory into practice: let us replace this function in I'76 with an upgraded version that computes the reciprocal
square root in a much more accurate way. How? We&rsquo;ll just patch the <code>i76_rsqrt</code> function and compute it directly on the FPU:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>float10</span> <span class=kr>__cdecl</span> <span class=nf>i76_rsqrt</span><span class=p>(</span><span class=kt>double</span> <span class=n>param_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>float10</span><span class=p>)</span><span class=mi>1</span> <span class=o>/</span> <span class=n>SQRT</span><span class=p>((</span><span class=n>float10</span><span class=p>)</span><span class=n>param_1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=err>0049</span><span class=nf>c310</span> <span class=nv>dd</span> <span class=mi>44</span> <span class=mi>24</span> <span class=mi>04</span>     <span class=nv>FLD</span>        <span class=kt>qword</span> <span class=nv>ptr</span> <span class=p>[</span><span class=nb>ESP</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>c314</span> <span class=nv>d9</span> <span class=nv>fa</span>           <span class=nb>FS</span><span class=nv>QRT</span>
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>c316</span> <span class=nv>d9</span> <span class=nv>e8</span>           <span class=nv>FLD1</span>
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>c318</span> <span class=nv>de</span> <span class=nv>f1</span>           <span class=nv>FDIVRP</span>
</span></span><span class=line><span class=cl><span class=err>0049</span><span class=nf>c31a</span> <span class=nv>c3</span>              <span class=nv>RET</span></span></span></code></pre></div><p>I chose to do it this way because mixing SSE and x87 instructions is usually not a great idea. And besides &ndash; we have to run a frame <em>limiter</em> already
to get the game to behave properly, so does it really matter if it&rsquo;s a little slower than the original?</p><p>This should compute the result rounded correctly within half an ULP when rounded to a <code>float64</code>. At <code>float80</code> precision (<code>float10</code> in Ghidra), it&rsquo;s
probably accurate within one ULP, maybe two.</p><h3 id=rsqrt-screenshots>Screenshots</h3><p>Here&rsquo;s a comparison between the original code and the new code:</p><p>Original code:</p><p><img src=trainingorig.png alt></p><p>New code:</p><p><img src=trainingfull.png alt></p><p>As you can see, there&rsquo;s not much you can tell from the screenshots. I can&rsquo;t tell if things look much different in motion, either.
So, the original approximation seems like it was pretty good! Here&rsquo;s a diff showing the differences between both screenshots:</p><p><img src=diff.png alt></p><p>The differences appear to be very minor, with the largest region of changed pixels on the roof of Jade&rsquo;s car. You can see a couple
of triangles are rendered at a slightly different shade in both versions.</p><h4 id=for-fun>For Fun</h4><p>For fun, I modified the reciprocal square root to be multiplied by <code>0.5</code> before it gets returned. What a difference that made:</p><p><img src=traininghalf.png alt></p><p>The cars shrunk! Also, the car can barely move and projectiles move <em>veeery</em> sloowly. Curiously only the texturing of the landscape
is affected, not the geometry itself.</p><h1 id=conclusion>Conclusion</h1><p>Well that was fun, wasn&rsquo;t it?</p><p>I suspect that a fast reciprocal square root function would have been a big deal in 1997, and especially earlier if it was present in the original
Mechwarrior 2. Being able to quickly normalize vectors would have made 3D graphics much easier to do
on the CPU, even if the results weren&rsquo;t perfect. Although methods have existed to do this since the mid eighties, it seems they weren&rsquo;t
well known outside of a few circles.</p><p>We&rsquo;re really lucky these days in that tricks like these are very often not even needed anymore.
Nowadays, you can just write <code>1.0/sqrt(x)</code> and expect good performance 99% of the time.
This code was written for a time when processors were a lot weaker, and you <em>needed</em> to be clever to get
things working at an acceptable speed. Bit-twiddling was the norm to get things done.
Now, fast reciprocal square root is a hardware feature of many processors out there,
so tricks like this are rarely even needed.
<em>In other words, you probably don&rsquo;t want to use this in new code</em>! But if you <em>do</em> need something like this,
C++20 makes it easier than it has ever been to write readable bit twiddling code.</p><p>Also, just a gentle reminder to always profile your code before attempting to optimize anything.
Do measurements, do test runs, etc. You&rsquo;ll thank yourself later! If you don&rsquo;t do this,
you might actually end up <em>hurting</em> your own performance by pre-emptively implementing something
like <code>i76_rsqrt</code> in new code.
Use a good profiler like <a href=https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html>vTune</a> to help you understand what parts
of your code are slow, and most importantly, <em>why</em>. There are so, so many things it could be, and chances
are you won&rsquo;t be able to figure it out by just looking at the code itself. <em>World experts</em> have a hard time figuring it out.
Save yourself the trouble! Write your code with clarity first, and profile afterwards. You might be surprised at what you see.</p><p>The code demonstrated in this article was designed to be clear from the get-go, to show how well clean code optimizes in C++20.
Even in 32-bit mode, MSVC optimizes the 64-bit values right out and basically transformed it into the original code,
and it&rsquo;s <em>way</em> easier to read. If a fellow human can understand your code, you bet the compiler can too!</p><p>For fun, you&rsquo;ll notice the LUT generation actually auto-vectorizes very well too &ndash; not
that it matters anyway, because it could have just been <code>constexpr</code> in the first place :) I expect the actual <code>rsqrt</code>
function would vectorize well enough too.</p><p>I&rsquo;ve put the code on <a href=https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVDIApACYAQjt2kR7ZATx1KmWugDCqVgFcAtrRAB2AKykr6ADJ5aTAA5ZwAjTGIuXgAHVCFCc1o7Rxd3L1j4szp/QJCncMieI0wTLNoGAmZiAmTnV09i0sSKqoIc4LCIqKNK6trUhqFetoCO/K6eAEojVAdiZA4pHQBmAORHLABqTWWbUMId7E0ZAEEVtY3Mbd3kIfx6Q%2BOz7VXadYctnZtbgmIA4Eep3Ob0u12%2BTmYBAQgLOpwA9AAqJ4AFQQVxorFYqAA7v9NmgtnghJtMOJoqpRuhNgFNlCiZtQljgJsMgQQE8EAQCNEhCA4XCAuECNjMFZaMwnJghAA6QIEOGM1DAOHaGTaTgAWhkHi1ADYNXg3LriEIAI7VOFPJ4ASQI1OJzE2xEwADcIiISepRhFMFS8E5yZhJfRIYlNqgqJsqMwhk7MMg8NFiKgWKxNmaHFUrsnUAQnjHqXbmNFopgs37aLS0ZtgBKrtb6O7KgQrmApEaracAGIOax1kOYgCehc2DhEDs2WNQAGsHNFacxGVciDXMHaIfQiUJHfsCEJSPnrOn/YGoyQnA5VLTUJssC3iE5RlX0VjQ%2BoWagAnbSbFAvQz8Qz5xkIl55qcCKWkCpxsHgwDikIEDLNokyjl%2BAAcAD6dq%2BAIyKaB4ujaB4ur4QAIjs%2BhQScLqflSwBWBEkKYDhyIQJMVpuJRJybDxAGbBADhfkhWHUtcpGbDIFGiV8mxESRyy6NsegGHg7GnLx2ycU8GkaYJ9C6twIloLQsZUK%2BBAGbuxI7OJEBDKGyAYSwQxfHpFmGXmyzYBAqmaTYmwCNaQTIgZGE2BAMjiJwVBUDIMiTChXwyZF2joBR2k6Tx6CzEu%2BJ0LGVI2emBDoCAIC7k5MaeTY2UOEuhzUOZlmEEI7EKRlmW1blxmxia5p2kVnDSjImxwsVpUgGa1QQOgbVcZlPFuaFdo9XaDgGX11RieNZUVc51VLR5DWbQQc0dTpbnCSt%2BV2ggsEIEhVnbfZZiOftrlCdoWENet3AndcRxeRJ4iqmdVELaNlraNoya9lSCBsFQGpzjo2jhqWxChhYmzMOgVIyJwcVE8TMihPxnBgjJhOTCAk44hEDIteGkYbmYQjbjjzpVsm2KVrMBDSudGn8nSxII8SUJXJgMXxnaEZOrM1h4pLmys1ujq4nSlYAJyM3uQu8fyY7K9WqOw0eKPQ06l5XJCQGExqu6q1U06C%2BpC38qweDTiUw47g4zI0irJCwQEbB5VgtNCAgsysFS4TA2hcXXnlxDOqYrDDubVIrmhetCAbi2fUZN2bHdwAPdoVkYdnvoYXO23l5XT0GMD3Bxel7uZW5mHXSZ65qGz24YU3aHV3QmfbRATePS1NeK1g6D1/OjxA5FyCJdouoBUFyLCeFkVdl2YOwtxHtwkMJDLtWedPfLavs46zoQgE/yF5sLH4boeBkdtD/D6PcetBM6dzPjxTQbhyJdw/rhL%2BkUk6/yKofLsoCIFQNPvybEfwuRWD4usKohBBy02ylKEkbpiCDi1syOgmwDKO0IJsF0bAHBSieF1dg1IjQ1ymgQGaOUOGrXTKmKoakzhaWgYdEu/chFsCqBhFuyxxJ3F2oQSqLldiSM8t5IQwjiAn3Oj3KRsYAhYHEFPHRsjiDyKZqvbAwNUqb23pFGKqDoH8k/gRExpJf7GUqAECWN9VZxDtPEOCeAqB4BYP%2BO%2BkYVb/2YKQBWcNfSjmiG7MBkNkTOjtmwNMWIRSAW4NwfOONiQAC8IioBSfzAxX5lp5WkfE6xe5nrNkiWog6dSjpeQgB47%2B1hvEeFIolXYyUQZaHal3c6/JsBkjoFYO0T0sz4jYMgS8TF44xmqZWFWNAHzrOpDs6srRInsFqfpDyDTYw/nmfQZp1lFH8QiuIUIVBkACF8JsDU/ELGqCsQowGdjIrLG4AlAGhxNicBGTYMZILQEaWmXCG5f4CD3LLswN0AEnDAwAJp4pJhJEmHc3FwiaU9BGmK9nYsikTAAWrSomhKiWIqEDeNA%2BRKSJJFOizFvFIp4pxfSxlRLk4am%2BY6dlgYWxRiasUvZQFgAsPZuc9yRjrocsCEvBR4lkULLRRA/yZKWquIycwBwK5BGvzMGwDCiqpQPKUSVFRqL3q7HYZgBq7L9iavufo6BZqLWlwRqwKgGErV4BtXa9m21w2RqVcSBEElpQeHhbxANbLS6xtYLa%2BNGEMzlhjbQBIcb7WbETVmnN9rU3gJJQAeUCIWRiZRmabCCJgbERBaAagAErFgQKy2g5101XLtIEDtdAa59oHVPZYw0vk/N0WWw5xbs1RqEHm00mZnSzRQom4NoaK1rpNcLOErINQx2QFGPA4gUb%2BvNRm6RESb0r0eWOztk7oj9poYmoaxNODHt4s6AgcxKxPpRgpbYQJIGdhOPydYcQpR2hXCHYAYc0wEkwIkkhxJXQREoXdd8QdqxN02EhEp8tHTuqePyBE0dY7oETagaIZhHwVJTirbckoqx4lCOa28VShC0DbHaGkABZBgAA1GFpx3WcN1Nw/qGEkJ8LqgI0uvyREcXmrxS6X0%2B6xg01Ypu%2BrHnKPKqo11NhNENUMyMwF9jJKTNPrpdCarDmmPMboke90TP2cirNJSTjxAuKc4ivpXjxA%2BLoH4kyQE85OGCceMJESomLKZvLOJg91aJNrlSOc6ST1ZLLEWTEdMCmbCKSUgsFTkzVPNSqq6I7nabkfiZx1DkOkfXoFdBq4WBmRaGdCsZEztOQYyTMuZKKqtc1TGs1QLZNkiCpDQ3Z54DlEdttUU5HqJHF309%2BSbertVPMiq895867JeeMwCiFkUph2YhVCymuxgY8GrWNk9uq7nkoxeic8uL8XEyZSTRFRqWkUr%2Bw%2BYGdKGXJxFZJElrK8oat9Fyq4EONL8rxUKuHIqvniuR1Kl8qBIQGT4irI9u3ut6aa16ykbWSSHe%2BzYtwhqsutasgBniw7LVFutau%2BNrSJp7Sql8KjPSXrtMs9ZnpdOfVWSGy9lK8Uuc43vU1/dYa%2BcRoF6Woqh7BeJpkMm97PPM3a5LezDdW6Un64t7r6N5b7eVuVU5hFdaG2ECbWGeWbbx1dt7Z%2BgdQ71eCLfROzGQeaFFUQnO75l3LFLoN/a635YwV7sRlrldLuC6hZJWei9V7n0h8DY%2B69Dcirh9oB%2Br9lYf3DSJv%2BvPGSgMgaL%2BBxSHF0FsP4VccUZg3QKemrJwRtnNi0CqeIBYzGtPnVb8QSsv6L5Osmv1BPfz9GQKkNMVg0gPDyFcLIeQqBpAwuUnodMsx5hXBWJweQbIj8JVINOEA3A3DSl1NrTgyxlgyGWITbWXUZYbWNCFQaQbgeQJwLgOKUgQ/OQUgE/KQeQXkGQUgB/OQaYOAWAJASVPAdgMgCgCAXA/AlAVQdQLCYgXsacPgPA%2B8XkCAUIaQeA71KoIhKQO/UgdlYMAgetTOJg%2BQLADcYAdgfg0gfAdOAfKUUQ0keMc1RYDgr8EoUQr2UITGChOwSOI/NAv4KA9g7fPgaLJgNgDgIofgAgYQMQSQLQpQbQFQNQDQAwAwFQPAUIXkSAaYJjMoXkKQDUWtaMWMDUO4GyLQc/QiMmDUJwMjCIqoZAaERRUsTcZwZAkoWWRISwawfoVwTgbwawdoPIAoZQDIBIOgTIwouIYo2gPIzoQoRoVIugFoPoewOoZQYwOo8oYYKo8YGo%2ByRolILInoVoTogoqFGYOYBYLgHfPfA/UQxA8QNCfUMnfBd8CAX4KglCCAXAQgEgJSf/RJOwAMPAhmFYZCTYM/fQPQe/fgp/F/TgNCaUbQNwI0bgW4zgQAtCZ43UMAqQCA2AmY6QZAkAVA9A/QrAxAFAVAA4/A8gSgYgroF0ZAEsDCF0V4jCebRDDCOYz4iJVgOgygRgrQlgihaQDgrghZXgtg%2BAwQ%2BwkQrQ8Q1It0bw%2BAmQtZFsYk%2BQRQ3fLQlQtQwcDQxYeA34f0Nk6YMwowkQ0w6LCwiQUQpQbIsghw0I5w1w%2BADw5jRIbwuEKgaIEAfwu0OEWtNGfU4cfUvAUaWtUIQ0mIpAa0E4MjZfUqEI843QNEoYZIpoCwCAHwUo7InwIYiYUgIosob0gM8osoP07olI0wZoYYYM1oqM%2Bojo0YfI/0nomoJo1IbI1M8MiY0Y6/ZQbEQeWtZjBsGgYUr4/fX4rQ2Y%2BY1WIQeExhV46UF0u0DY/AIgQCW/PYiE6IQ4jsl4J7M4gwS4x/aYNEXGLoNiZ/Lgd/AmDwDwb/bWEFXUTwRctwL4n4uA4/f4owQEtAq40gUE6ecErATY9s6E6gQw1MEw3gMwqUqw%2BAmwuw9QEANQNgQceIfcOMsodI2wdM%2BoHIvwJM6okAeckMzIRIUotcwMxIbM0Cr86M1oSC2o%2BM9owYoCrokCzMmMv89wAY6oWCkY1lMYxYCiWtP4VDcUNMeiQITGFsVE%2BrU4ECMmKUaIUgQmCGDizi3iJ4cQbYsscQbwZgMxLikSnSJ4BLF0W8bEEgKkZjQCdmdkAiFisiQS4SkS8S1ASS%2BMAS/i0SvSmtE4Pi5AASzgI%2BZOfS9SxihANMbS0gcSCyvSjSyS9AaS4gWS34dMXkL%2BZSvQbgFS7Syyk4MyKkIYCKaYU0Vy9y%2BSrypSoQaIX%2BLip4KgHhBy1KpK/AF0eS3heKUgCKmSlkDy9AGK3QbgGwDwU4SSIZBaJKoYecPKtygq6KxS3QHy3QNCFS0K%2BKDipykkdAASly/KuSzy5q1qmFKqxK6CPGXqgS9uEaVKzip4bcQCX0AS/yeaiak4CShkShK4IaoqkaoSgwDwLsXQW4yq0iMQtMCGJ4NYEkIS9a0Sp4ZAAMO6ky8yh6zKJ4BQNMPnZMaUbgbWE4LsT/D67i04La0IHaxq28Yq46wiDuIZUgI%2BR6yaqkFitiua0GsS04IDGDUi8itDOTIfMCTazSkkYysQyK6GhS7yuKgwdq8aha8Gsmla0gXQLsNarGsGk4aOZaimngLm7G0mrSoSymwajymm2K%2BKvQBm%2BypmnmhAZa0WuWwWgypi6a7wYy1WtWxWjWimbWgytQNG0W5Gg2pKuOYqMK3KqmoayWlqum3yhK66qymyvqti4pM25myStgUgSG6VPa4q/io6k6s6p2z6l2160gTm7WnioynSrWmO04Pit23Sz24WqS8Wpq2m6Wkq/yhO%2BWragahq22wOh2tq/yvqwK4Ky2nK%2BqqK4a7OgwPyxm6q04KgC8NMTq6YLurG82kK7K8Km2iW0unO5ulW8OoKqfBAGu7u3hJ7UGpKju%2BcUK5CHoMKhetujume62zOmG5q8qzgTgXUWW52ye2I7e0K%2Bej6mquqLKq2uu6G/ar%2BA%2Bo%2B861uoKpey2wigejej%2By8beh%2BgO/egmTgNwN%2B9%2BoDXifQzkiszchA6QE4Si98%2BkIi6/HY7QYcjA6YG4mczgOchcpclc5YNczkjcv4pAncoEq4yYqQDBys%2BAxAzB7faYcheICwbgIAA%3D%3D>Compiler Explorer</a> in case anyone wants to play around with it.</p><p>Do note that building on different compilers could give <a href=#fp-assoc>slightly different results</a> if fast math is enabled.</p><p>Thanks for tuning in! This article took me way too long to write, but I&rsquo;m sure glad I got it out of my system.</p><p>Next up in my I'76 hacking: finding an old bug where ramming your car in Nitro would cause your health to reset (I suspect it&rsquo;s an overflow bug).</p><h1 id=appendix>Appendix</h1><h2 id=ieee754-cases>IEEE-754 special cases</h2><p>Special cases of IEEE-754 binary datatypes:</p><ul><li>Zero is represented by zeroing out all bits in the datatype</li><li><code>Inf</code> is represented by setting all exponent bits to $1$ and all mantissa bits to $0$<ul><li>The sign bit determines whether it is <code>+Inf</code> or <code>-Inf</code></li></ul></li><li><a href=https://en.wikipedia.org/wiki/NaN>NaN</a> (<em>Not-a-Number</em>) is represented by setting all exponent bits to $1$<ul><li>The sign bit determines whether the <code>NaN</code> is signaling or quiet</li><li>At least one mantissa bit is set to $0$</li></ul></li><li><a href=https://en.wikipedia.org/wiki/Denormal_number>Subnormal numbers</a> have all exponent bits set to $0$ with at least one mantissa bit set to $1$</li></ul><h2 id=ieee754-decomp>IEEE-754 floating point decomposition</h2><p>Let $x \in \mathbb{R}, x > 0$. Then:</p><span>\[x = 2^\floor{\lg\left(x\right)}*\frac{x}{2^\floor{\lg\left(x\right)}}\]</span><p>This works because:</p><span>\begin{aligned}& 0 \leq \lg\left(x\right) - \floor{\lg\left(x\right)} &lt; 1 \\
\implies& 2^0 \leq 2^{\lg\left(x\right) - \floor{\lg\left(x\right)}} &lt; 2^1 \\
\implies& 1 \leq \frac{2^{\lg\left(x\right)}}{2^\floor{\lg\left(x\right)}} &lt; 2 \\
\implies& 1 \leq \frac{x}{2^\floor{\lg\left(x\right)}} &lt; 2\end{aligned}</span><p>Therefore,</p><span>\[(\exists \fexp \in \mathbb{Z})(\exists \ffrac \in \mathbb{R})\ 0 \leq \ffrac &lt; 1 \text{ and } x = 2^{\fexp}(1 + \ffrac)\]</span><p>We call this is the <em>floating-point decomposition</em> of $x$.</p><p>Handling negative values is simple as well &ndash; treat it as a positive value and then set the sign bit accordingly.</p><h2 id=ieee754-real>Approximating a real number using a <code>float64</code></h2><p>Note that the notation we use is one way: it takes a non-zero, finite IEEE-754 value $v$ and lets us treat it as though it were a real.
To go the <em>other</em> way, that is, to take a non-zero $x \in \mathbb{R}$ and represent it as a <code>float64</code>, first let $x = /pm2^\fexp(1 + \ffrac)$ be the floating
point decomposition of $x$. The following two conditions must hold:</p><p><span>\[-1023 &lt; \fexp &lt; 1024 \tag{1}\]</span>
<span>\[(\exists z \in \mathbb{Z})\ \ffrac = \dfrac{z}{2^{52}} \tag{2}\]</span></p><p>$\ffrac$ can be <a href=https://en.wikipedia.org/wiki/Floating-point_arithmetic#Rounding_modes>rounded</a> to satisfy condition (2) &ndash; in this case, the <code>float64</code> is an approximation
of the real value.</p><p>Representing $0$ requires using a <a href=#ieee754-cases>special case</a> in the <code>float64</code> format.</p><h2 id=fp-assoc>Floating point associativity</h2><p>You may notice that if you attempt to build the code using fast math, you get results that are not identical across the MSVC and Clang compilers.
This is due to the compiler reordering the floating point operations &ndash; something it would ordinarily not be permitted to do without <code>-Ofast</code> or equivalent.</p><p>For example, on Clang 11, the compiler chooses to evaluate this code in <code>i76_rsqrt</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=k>const</span> <span class=n>half_initial_guess</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=k>const</span> <span class=n>initial_guess_squared</span> <span class=o>=</span> <span class=n>initial_guess</span> <span class=o>*</span> <span class=n>initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=k>const</span> <span class=n>newton_raphson</span> <span class=o>=</span> <span class=p>(</span><span class=mf>3.0</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar</span> <span class=o>*</span> <span class=n>initial_guess_squared</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                          <span class=o>*</span> <span class=n>half_initial_guess</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=k>const</span> <span class=n>fixup</span> <span class=o>=</span> <span class=n>newton_raphson</span> <span class=o>*</span> <span class=mf>1.00001</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>fixup</span><span class=p>;</span></span></span></code></pre></div><p>as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>return</span> <span class=p>((</span><span class=mf>3.0</span> <span class=o>-</span> <span class=p>(</span><span class=n>scalar</span> <span class=o>*</span> <span class=n>initial_guess_squared</span><span class=p>))</span> <span class=o>*</span> <span class=p>(</span><span class=n>initial_guess</span> <span class=o>*</span> <span class=p>(</span><span class=mf>0.5</span> <span class=o>*</span> <span class=mf>1.00001</span><span class=p>)));</span></span></span></code></pre></div><p>Note the shifting of the parentheses: <code>(initial_guess * 0.5) * 1.00001</code> is changed to <code>initial_guess * (0.5 * 1.00001)</code>.
In pure math, these expressions are equivalent because addition and multiplication on the reals are associative.
That is, the following two statements hold for all $a, b, c \in \mathbb{R}$:</p><p><span>\[(a + b) + c = a + (b + c)\]</span>
<span>\[a(bc) = (ab)c\]</span></p><p>However this is not the case for floating point operations due to the rounding that occurs after each operation. Since floating point types have a fixed size,
the result of each operation needs to be rounded to fit within the datatype. There are different <a href=https://en.wikipedia.org/wiki/IEEE_754#Rounding_rules>rounding modes</a> available to achieve this.
Since floating point math isn&rsquo;t associative in general, the optimization above actually doesn&rsquo;t preserve the original program semantics.
However, it <em>is</em> faster &ndash; <code>0.5 * 1.00001</code> is evaluated at compile time, saving one multiplication at run-time.</p><p>Does it matter? Well, it depends on the code, really. For an approximation like <code>i76_rsqrt</code>, it&rsquo;s well within the error
and doesn&rsquo;t matter one bit, and these applications are precisely why compilers offer fast math options.
For algorithms that really depend on having things done in a certain order to minimize <a href=https://en.wikipedia.org/wiki/Round-off_error>roundoff error</a>?
Then you bet it matters a great deal! This is why fast math optimizations are not enabled by default in most compilers.</p><h2 id=ieee-x87>x87 refresher</h2><p>Back in 1997, things like SSE and AVX didn&rsquo;t quite exist yet on x86. I think MMX might have
just recently been released, but it wasn&rsquo;t something you could rely on being there. What you most likely had
was the x87 instruction set to work with, and this thing came with a number of peculiarities.
Originally an optional co-processor on earlier Intel chipsets, it was integrated into the CPU
proper with the advent of the i487. The co-processor nature of it is reflected in the ISA itself.
It has it&rsquo;s own floating point stack, and interacting with it involves pushing, reordering, and popping things from that stack.
It also curiously has it&rsquo;s own 80-bit floating point representation internally, which seems
to essentially be <code>float64</code> with extra mantissa bits and an explicit normalization bit.</p><p>Branching was likely expensive back then, as <a href=https://en.wikipedia.org/wiki/Out-of-order_execution>out of order execution</a>
and its cousin <a href=https://en.wikipedia.org/wiki/Speculative_execution>speculative execution</a> were not really a thing on x86 quite yet (the Pentium Pro was
launched just 2 years prior). However, <a href=https://en.wikipedia.org/wiki/X87>superscalar</a> execution definitely <em>was</em> a thing, since x87 coprocessor ran in parallel
with the the x86 core. Since the pipeline was in-order, branching might have incurred a <a href=https://en.wikipedia.org/wiki/Pipeline_stall>performance penalty</a>
as execution could not proceed until the branch was resolved.</p></article><nav class="no-print post-nav"><a class=prev-post href=https://inbetweennames.net/blog/2021-05-04-interstate-76-reverse-engineering-efforts-the-story-so-far/><img class=icon-text src=/img/prev.svg>Interstate '76 Reverse Engineering</a></nav><section id=related><h4>See Also</h4><ul><li><a href=/blog/2021-05-04-interstate-76-reverse-engineering-efforts-the-story-so-far/>Interstate '76 Reverse Engineering</a></li><li><a href=/projects/interstate76anet/>Interstate '76/Nitro pack netcode patches</a></li></ul></section><hr class=sep></main><footer class="container no-print"><div class=u-footer><div style=margin-bottom:2rem><a href=mailto:lookatyouhacker@gmail.com><img class=icon-sc src=/img/email.svg alt=E-mail></a>
<a href=https://github.com/InBetweenNames/><img class=icon-sc src=/img/github.svg alt=GitHub></a>
<a href=https://www.linkedin.com/in/shane-peelar-29a2005a/><img class=icon-sc src=/img/l_in.svg alt=LinkedIn></a></div><a href=https://inbetweennames.net/index.xml target=_blank><img class=icon-sc src=/img/feed.svg alt="RSS Feed"></a><p>Theme used: <a href=https://github.com/InBetweenNames/manis-hugo-theme>ManisIBN</a><br>&copy; 2022 Shane Peelar<div><a href=/privacypolicy/>Privacy Policy</a></div></p></div></footer></body></html>